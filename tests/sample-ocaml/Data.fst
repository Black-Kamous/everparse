module Data

(* This file has been automatically generated by EverParse. *)
open FStar.Bytes
module U8 = FStar.UInt8
module U16 = FStar.UInt16
module U32 = FStar.UInt32
module U64 = FStar.UInt64
module LP = LowParse.Spec
module LPI = LowParse.Spec.AllIntegers
module L = FStar.List.Tot
module BY = FStar.Bytes

#reset-options "--using_facts_from '* -FStar.Tactics -FStar.Reflection' --z3rlimit 16 --z3cliopt smt.arith.nl=false --max_fuel 2 --max_ifuel 2"

friend Boolean

// Need high Z3 limits for large sum types
#set-options "--z3rlimit 120"

inline_for_extraction unfold let boolean_as_enum_key (x:boolean) : Pure (LP.enum_key boolean_enum)
  (requires norm [delta; zeta; iota; primops] (LP.list_mem x (LP.list_map fst boolean_enum)) == true) (ensures fun _ -> True) =
  [@inline_let] let _ = norm_spec [delta; zeta; iota; primops] (LP.list_mem x (LP.list_map fst boolean_enum)) in x

inline_for_extraction let key_of_data (x:data) : LP.enum_key boolean_enum =
  match x with
  | Payloads_TRUE _ -> boolean_as_enum_key TRUE
  | Payloads_FALSE _ -> boolean_as_enum_key FALSE

inline_for_extraction let data_case_of_boolean (x:boolean) : Type0 =
  match x with
  | TRUE -> U32.t
  | FALSE -> U16.t

unfold inline_for_extraction let to_data_case_of_boolean (x:boolean) (#x':boolean) (y:data_case_of_boolean x')  : Pure (norm [delta_only [(`%data_case_of_boolean)]; iota] (data_case_of_boolean x))
  (requires (x == x')) (ensures (fun y' -> y' == y)) =
  [@inline_let] let _ = norm_spec [delta_only [(`%data_case_of_boolean)] ; iota] (data_case_of_boolean x) in y

unfold inline_for_extraction let data_refine (k:LP.enum_key boolean_enum) (x:data)
  : Pure (LP.refine_with_tag key_of_data k)  (requires norm [delta; iota; zeta] (key_of_data x) == k) (ensures (fun y -> y == x)) =
  [@inline_let] let _ = norm_spec [delta; iota; zeta] (key_of_data x) in x

inline_for_extraction let synth_data_cases (x:LP.enum_key boolean_enum) (y:data_case_of_boolean x)
  : LP.refine_with_tag key_of_data x =
  match x with
  | TRUE -> data_refine x (Payloads_TRUE (to_data_case_of_boolean TRUE y))
  | FALSE -> data_refine x (Payloads_FALSE (to_data_case_of_boolean FALSE y))

unfold inline_for_extraction let from_data_case_of_boolean (#x':boolean) (x:boolean)
  (y: norm [delta_only [(`%data_case_of_boolean)]; iota] (data_case_of_boolean x))
  : Pure (data_case_of_boolean x') (requires (x == x')) (ensures (fun y' -> y' == y)) =
  [@inline_let] let _ = norm_spec [delta_only [(`%data_case_of_boolean)] ; iota] (data_case_of_boolean x) in y

let synth_data_cases_recip_pre (k:LP.enum_key boolean_enum)
  (x:LP.refine_with_tag key_of_data k) : GTot bool =
  match k with
  | TRUE -> Payloads_TRUE? x
  | FALSE -> Payloads_FALSE? x

let synth_data_cases_recip_pre_intro (k:LP.enum_key boolean_enum) (x:LP.refine_with_tag key_of_data k)
  : Lemma (synth_data_cases_recip_pre k x == true) =
  norm_spec [delta; iota] (synth_data_cases_recip_pre k x)

inline_for_extraction let synth_data_cases_recip (k:LP.enum_key boolean_enum)
  (x:LP.refine_with_tag key_of_data k) : (data_case_of_boolean k) =
  match k with
  | TRUE -> [@inline_let] let _ = synth_data_cases_recip_pre_intro TRUE x in
    (match x with Payloads_TRUE y -> (from_data_case_of_boolean TRUE y))
  | FALSE -> [@inline_let] let _ = synth_data_cases_recip_pre_intro FALSE x in
    (match x with Payloads_FALSE y -> (from_data_case_of_boolean FALSE y))

inline_for_extraction let data_sum = LP.make_sum' boolean_enum key_of_data
  data_case_of_boolean synth_data_cases synth_data_cases_recip
  (_ by (LP.make_sum_synth_case_recip_synth_case_tac ()))
  (_ by (LP.synth_case_synth_case_recip_tac ()))

let parse_data_cases (x:LP.sum_key data_sum)
  : k:LP.parser_kind & LP.parser k (data_case_of_boolean x) =
  match x with
  | TRUE -> [@inline_let] let u : (k: LP.parser_kind & LP.parser k (data_case_of_boolean TRUE)) = (| _, LPI.parse_u32 |) in u
  | FALSE -> [@inline_let] let u : (k: LP.parser_kind & LP.parser k (data_case_of_boolean FALSE)) = (| _, LPI.parse_u16 |) in u
  | _ -> (| _, LP.parse_false |)

noextract let serialize_data_cases (x:LP.sum_key data_sum)
  : LP.serializer (dsnd (parse_data_cases x)) =
  match x with
  | TRUE -> [@inline_let] let u : LP.serializer (dsnd (parse_data_cases TRUE)) = LPI.serialize_u32 in u
  | FALSE -> [@inline_let] let u : LP.serializer (dsnd (parse_data_cases FALSE)) = LPI.serialize_u16 in u
  | _ -> LP.serialize_false

let data_parser =
  assert_norm (LP.parse_sum_kind (LP.get_parser_kind boolean_repr_parser) data_sum parse_data_cases == data_parser_kind);
  LP.parse_sum data_sum boolean_repr_parser parse_data_cases

let data_serializer =
  assert_norm (LP.parse_sum_kind (LP.get_parser_kind boolean_repr_parser) data_sum parse_data_cases == data_parser_kind);
  LP.serialize_sum data_sum boolean_repr_serializer serialize_data_cases

let data_bytesize (x:data) : GTot nat = Seq.length (data_serializer x)

let data_bytesize_eq x = ()
