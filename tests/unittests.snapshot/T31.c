/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: /home/tahina/everest/master/kremlin/krml -ccopt -Ofast -drop FStar.Tactics.\* -drop FStar.Tactics -drop FStar.Reflection.\* -tmpdir out -I .. -bundle LowParse.\* -add-include "kremlin/internal/compat.h" -warn-error -9 ../../src/lowparse/LowParse_TestLib_Low_c.c -no-prefix Test kremlin/FStar_Pervasives_Native.krml kremlin/FStar_Pervasives.krml kremlin/FStar_Preorder.krml kremlin/FStar_Calc.krml kremlin/FStar_Squash.krml kremlin/FStar_Classical.krml kremlin/FStar_StrongExcludedMiddle.krml kremlin/FStar_FunctionalExtensionality.krml kremlin/FStar_List_Tot_Base.krml kremlin/FStar_List_Tot_Properties.krml kremlin/FStar_List_Tot.krml kremlin/FStar_Seq_Base.krml kremlin/FStar_Seq_Properties.krml kremlin/FStar_Seq.krml kremlin/FStar_Mul.krml kremlin/FStar_Math_Lib.krml kremlin/FStar_Math_Lemmas.krml kremlin/FStar_BitVector.krml kremlin/FStar_UInt.krml kremlin/FStar_UInt32.krml kremlin/FStar_Int.krml kremlin/FStar_Int16.krml kremlin/FStar_Range.krml kremlin/FStar_Reflection_Types.krml kremlin/FStar_Tactics_Types.krml kremlin/FStar_Tactics_Result.krml kremlin/FStar_Tactics_Effect.krml kremlin/FStar_Tactics_Util.krml kremlin/FStar_Reflection_Data.krml kremlin/FStar_Reflection_Const.krml kremlin/FStar_Char.krml kremlin/FStar_Exn.krml kremlin/FStar_Set.krml kremlin/FStar_Monotonic_Witnessed.krml kremlin/FStar_Ghost.krml kremlin/FStar_ErasedLogic.krml kremlin/FStar_PropositionalExtensionality.krml kremlin/FStar_PredicateExtensionality.krml kremlin/FStar_TSet.krml kremlin/FStar_Monotonic_Heap.krml kremlin/FStar_Heap.krml kremlin/FStar_ST.krml kremlin/FStar_All.krml kremlin/FStar_List.krml kremlin/FStar_String.krml kremlin/FStar_Order.krml kremlin/FStar_Reflection_Basic.krml kremlin/FStar_Reflection_Derived.krml kremlin/FStar_Tactics_Builtins.krml kremlin/FStar_Reflection_Formula.krml kremlin/FStar_Reflection_Derived_Lemmas.krml kremlin/FStar_Reflection.krml kremlin/FStar_Tactics_Derived.krml kremlin/FStar_Tactics_Logic.krml kremlin/FStar_Tactics.krml kremlin/FStar_Map.krml kremlin/FStar_Monotonic_HyperHeap.krml kremlin/FStar_Monotonic_HyperStack.krml kremlin/FStar_HyperStack.krml kremlin/FStar_HyperStack_ST.krml kremlin/FStar_Universe.krml kremlin/FStar_GSet.krml kremlin/FStar_ModifiesGen.krml kremlin/FStar_BigOps.krml kremlin/LowStar_Monotonic_Buffer.krml kremlin/LowStar_Buffer.krml kremlin/FStar_UInt8.krml kremlin/LowParse_Bytes.krml kremlin/LowParse_Spec_Base.krml kremlin/LowParse_Spec_Combinators.krml kremlin/LowParse_Spec_FLData.krml kremlin/Spec_Loops.krml kremlin/FStar_UInt64.krml kremlin/LowStar_BufferOps.krml kremlin/C_Loops.krml kremlin/LowParse_Math.krml kremlin/LowParse_Slice.krml kremlin/LowParse_Low_Base.krml kremlin/LowParse_Low_Combinators.krml kremlin/LowParse_Low_FLData.krml kremlin/FStar_Int64.krml kremlin/FStar_Int63.krml kremlin/FStar_Int32.krml kremlin/FStar_Int8.krml kremlin/FStar_UInt63.krml kremlin/FStar_UInt16.krml kremlin/FStar_Int_Cast.krml kremlin/FStar_HyperStack_All.krml kremlin/FStar_Kremlin_Endianness.krml kremlin/LowParse_BigEndian.krml kremlin/LowParse_Spec_Int_Aux.krml kremlin/LowParse_Spec_Int.krml kremlin/LowParse_Spec_BoundedInt.krml kremlin/LowStar_Modifies.krml kremlin/LowStar_ModifiesPat.krml kremlin/LowParse_BigEndianImpl_Base.krml kremlin/LowParse_BigEndianImpl_Low.krml kremlin/LowParse_Low_BoundedInt.krml kremlin/LowParse_Spec_SeqBytes_Base.krml kremlin/LowParse_Spec_DER.krml kremlin/LowParse_Spec_BCVLI.krml kremlin/LowParse_Spec_AllIntegers.krml kremlin/LowParse_Spec_VLData.krml kremlin/LowParse_Low_VLData.krml kremlin/LowParse_Spec_VLGen.krml kremlin/LowParse_Low_VLGen.krml kremlin/LowParse_Spec_Int_Unique.krml kremlin/LowParse_Low_Int_Aux.krml kremlin/LowParse_Low_Int.krml kremlin/LowParse_Low_DER.krml kremlin/LowParse_Low_BCVLI.krml kremlin/LowParse_Spec_List.krml kremlin/LowParse_Low_List.krml kremlin/LowParse_Spec_Array.krml kremlin/LowParse_Spec_VCList.krml kremlin/LowParse_Low_VCList.krml kremlin/LowParse_Spec_IfThenElse.krml kremlin/LowParse_Low_IfThenElse.krml kremlin/LowParse_TacLib.krml kremlin/LowParse_Spec_Enum.krml kremlin/LowParse_Spec_Sum.krml kremlin/LowParse_Low_Enum.krml kremlin/LowParse_Low_Sum.krml kremlin/LowParse_Low_Tac_Sum.krml kremlin/LowParse_Spec_Option.krml kremlin/LowParse_Low_Option.krml kremlin/FStar_Bytes.krml kremlin/LowParse_Bytes32.krml kremlin/LowParse_Spec_Bytes.krml kremlin/LowParse_Low_Bytes.krml kremlin/LowParse_Low_Array.krml kremlin/LowParse_Low.krml kremlin/LowParse_SLow_Base.krml kremlin/LowParse_SLow_Combinators.krml kremlin/LowParse_SLow_FLData.krml kremlin/LowParse_SLow_VLGen.krml kremlin/LowParse_BigEndianImpl_SLow.krml kremlin/LowParse_SLow_BoundedInt.krml kremlin/LowParse_SLow_Int_Aux.krml kremlin/LowParse_SLow_Int.krml kremlin/LowParse_SLow_DER.krml kremlin/LowParse_SLow_BCVLI.krml kremlin/LowParse_SLow_List.krml kremlin/LowParse_SLow_VCList.krml kremlin/LowParse_SLow_IfThenElse.krml kremlin/LowParse_SLow_Option.krml kremlin/LowParse_SLow_Enum.krml kremlin/LowParse_SLow_Sum.krml kremlin/LowParse_SLow_Tac_Enum.krml kremlin/LowParse_SLow_Tac_Sum.krml kremlin/LowParse_SLow_VLData.krml kremlin/LowParse_SLow_Bytes.krml kremlin/LowParse_SLow_Array.krml kremlin/LowParse_Spec_Tac_Combinators.krml kremlin/LowParse_SLow.krml kremlin/Tag2.krml kremlin/T15_body.krml kremlin/T3.krml kremlin/T5.krml kremlin/T9_b.krml kremlin/Amount.krml kremlin/Txout_scriptPubKey.krml kremlin/Txout.krml kremlin/Transaction_outputs.krml kremlin/Txin_scriptSig.krml kremlin/Sha256.krml kremlin/Txin.krml kremlin/Transaction_inputs.krml kremlin/Transaction.krml kremlin/Block_tx.krml kremlin/Block.krml kremlin/T25_bpayload.krml kremlin/FStar_Int128.krml kremlin/FStar_Int31.krml kremlin/FStar_UInt128.krml kremlin/FStar_UInt31.krml kremlin/FStar_Integers.krml kremlin/FStar_Printf.krml kremlin/Tagle.krml kremlin/T4.krml kremlin/T6le.krml kremlin/T24_y.krml kremlin/T24.krml kremlin/T25_payload.krml kremlin/T25.krml kremlin/T14_x.krml kremlin/T13_x.krml kremlin/T13.krml kremlin/T18_x_b.krml kremlin/T20.krml kremlin/T21.krml kremlin/C_Endianness.krml kremlin/C.krml kremlin/C_String.krml kremlin/T26.krml kremlin/Tag.krml kremlin/T16_x.krml kremlin/T16.krml kremlin/LowStar_ImmutableBuffer.krml kremlin/FStar_HyperStack_IO.krml kremlin/LowParse_TestLib_Low.krml kremlin/T18_x_a.krml kremlin/T33.krml kremlin/T19.krml kremlin/T1.krml kremlin/T17_x_b.krml kremlin/T22_body_b.krml kremlin/T12_z.krml kremlin/T12.krml kremlin/T2.krml kremlin/T7.krml kremlin/T8_z.krml kremlin/T27.krml kremlin/T14.krml kremlin/T32.krml kremlin/T29.krml kremlin/T36.krml kremlin/T10.krml kremlin/T17_x_a.krml kremlin/T17.krml kremlin/T15.krml kremlin/T35.krml kremlin/T22_body_a.krml kremlin/FStar_Float.krml kremlin/FStar_IO.krml kremlin/T18.krml kremlin/T23.krml kremlin/T9.krml kremlin/T8.krml kremlin/T28.krml kremlin/T6.krml kremlin/Test.krml kremlin/T30.krml kremlin/T11_z.krml kremlin/T34.krml kremlin/T11.krml kremlin/T31.krml kremlin/T22.krml -o test.exe
  F* version: 74c6d2a5
  KreMLin version: 1bd260eb
 */

#include "T31.h"

bool T31_check_t31_list_bytesize(Prims_list__T13_t13 *l)
{
  bool b = true;
  K___bool_K___uint32_t_Prims_list__T13_t13
  x0 = { .fst = true, .snd = { .fst = (uint32_t)0U, .snd = l } };
  while (b)
  {
    K___uint32_t_Prims_list__T13_t13 x = x0.snd;
    uint32_t len1 = x.fst;
    Prims_list__T13_t13 *rem1 = x.snd;
    K___bool_K___uint32_t_Prims_list__T13_t13 ite;
    if (rem1->tag == Prims_Nil)
      ite = ((K___bool_K___uint32_t_Prims_list__T13_t13){ .fst = false, .snd = x });
    else if (rem1->tag == Prims_Cons)
    {
      Prims_list__T13_t13 *q = rem1->tl;
      T13_t13 a = rem1->hd;
      uint32_t sza = T13_t13_size32(a);
      uint32_t len_;
      if ((uint32_t)4294967295U - sza < len1)
        len_ = (uint32_t)4294967295U;
      else
        len_ = len1 + sza;
      if (len_ == (uint32_t)4294967295U)
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__T13_t13), (uint32_t)1U);
        Prims_list__T13_t13 *buf = KRML_HOST_MALLOC(sizeof (Prims_list__T13_t13));
        buf[0U] = ((Prims_list__T13_t13){ .tag = Prims_Nil });
        ite =
          (
            (K___bool_K___uint32_t_Prims_list__T13_t13){
              .fst = false,
              .snd = { .fst = (uint32_t)4294967295U, .snd = buf }
            }
          );
      }
      else
        ite =
          (
            (K___bool_K___uint32_t_Prims_list__T13_t13){
              .fst = true,
              .snd = { .fst = len_, .snd = q }
            }
          );
    }
    else
      ite =
        KRML_EABORT(K___bool_K___uint32_t_Prims_list__T13_t13,
          "unreachable (pattern matches are exhaustive in F*)");
    x0 = ite;
    b = x0.fst;
  }
  K___bool_K___uint32_t_Prims_list__T13_t13 scrut = x0;
  K___uint32_t_Prims_list__T13_t13 scrut0 = scrut.snd;
  uint32_t x = scrut0.fst;
  return (uint32_t)12U <= x && x <= (uint32_t)131072U;
}

typedef struct K___Prims_list__T13_t13_Prims_list__T13_t13_s
{
  Prims_list__T13_t13 *fst;
  Prims_list__T13_t13 *snd;
}
K___Prims_list__T13_t13_Prims_list__T13_t13;

typedef struct K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13_s
{
  bool fst;
  K___Prims_list__T13_t13_Prims_list__T13_t13 snd;
}
K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13;

Prims_list__T13_t13 *LowParse_SLow_List_list_rev__T13_t13(Prims_list__T13_t13 *l)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__T13_t13), (uint32_t)1U);
    Prims_list__T13_t13 *buf = KRML_HOST_MALLOC(sizeof (Prims_list__T13_t13));
    buf[0U] = ((Prims_list__T13_t13){ .tag = Prims_Nil });
    return buf;
  }
  else
  {
    bool b = true;
    KRML_CHECK_SIZE(sizeof (Prims_list__T13_t13), (uint32_t)1U);
    Prims_list__T13_t13 *buf = KRML_HOST_MALLOC(sizeof (Prims_list__T13_t13));
    buf[0U] = ((Prims_list__T13_t13){ .tag = Prims_Nil });
    K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13
    x0 = { .fst = true, .snd = { .fst = l, .snd = buf } };
    while (b)
    {
      K___Prims_list__T13_t13_Prims_list__T13_t13 x = x0.snd;
      Prims_list__T13_t13 *rem1 = x.fst;
      Prims_list__T13_t13 *acc = x.snd;
      K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13 ite;
      if (rem1->tag == Prims_Nil)
        ite =
          (
            (K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13){
              .fst = false,
              .snd = { .fst = rem1, .snd = acc }
            }
          );
      else if (rem1->tag == Prims_Cons)
      {
        Prims_list__T13_t13 *q = rem1->tl;
        T13_t13 a = rem1->hd;
        KRML_CHECK_SIZE(sizeof (Prims_list__T13_t13), (uint32_t)1U);
        Prims_list__T13_t13 *buf = KRML_HOST_MALLOC(sizeof (Prims_list__T13_t13));
        buf[0U] = ((Prims_list__T13_t13){ .tag = Prims_Cons, .hd = a, .tl = acc });
        ite =
          (
            (K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13){
              .fst = true,
              .snd = { .fst = q, .snd = buf }
            }
          );
      }
      else
        ite =
          KRML_EABORT(K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13,
            "unreachable (pattern matches are exhaustive in F*)");
      x0 = ite;
      b = x0.fst;
    }
    K___bool_K___Prims_list__T13_t13_Prims_list__T13_t13 scrut = x0;
    K___Prims_list__T13_t13_Prims_list__T13_t13 scrut0 = scrut.snd;
    return scrut0.snd;
  }
}

FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t
T31_t31_parser32(FStar_Bytes_bytes input)
{
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t
  scrut0 = LowParse_SLow_BoundedInt_parse32_bounded_integer_le_1(input);
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t scrut1;
  if (scrut0.tag == FStar_Pervasives_Native_None)
    scrut1 =
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (scrut0.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed_x = scrut0.v.snd;
    uint32_t x32 = scrut0.v.fst;
    if (x32 < (uint32_t)253U && (uint32_t)12U <= x32 && x32 <= (uint32_t)131072U)
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = x32, .snd = consumed_x }
          }
        );
    else if ((uint32_t)131072U < (uint32_t)253U)
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (x32 == (uint32_t)253U)
      if ((uint32_t)65536U <= (uint32_t)12U)
        scrut1 =
          (
            (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else
      {
        FStar_Bytes_bytes input_ = FStar_Bytes_slice(input, consumed_x, FStar_Bytes_len(input));
        FStar_Pervasives_Native_option__K___uint32_t_uint32_t
        scrut = LowParse_SLow_BoundedInt_parse32_bounded_integer_le_2(input_);
        if (scrut.tag == FStar_Pervasives_Native_None)
          scrut1 =
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed_y = scrut.v.snd;
          uint32_t y = scrut.v.fst;
          if (y < (uint32_t)253U || y < (uint32_t)12U || (uint32_t)131072U < y)
            scrut1 =
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
          else
            scrut1 =
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { .fst = y, .snd = consumed_x + consumed_y }
                }
              );
        }
        else
          scrut1 =
            KRML_EABORT(FStar_Pervasives_Native_option__K___uint32_t_uint32_t,
              "unreachable (pattern matches are exhaustive in F*)");
      }
    else if ((uint32_t)131072U < (uint32_t)65536U)
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (x32 == (uint32_t)254U)
    {
      FStar_Bytes_bytes input_ = FStar_Bytes_slice(input, consumed_x, FStar_Bytes_len(input));
      FStar_Pervasives_Native_option__K___uint32_t_uint32_t
      scrut = LowParse_SLow_BoundedInt_parse32_bounded_integer_le_4(input_);
      if (scrut.tag == FStar_Pervasives_Native_None)
        scrut1 =
          (
            (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed_y = scrut.v.snd;
        uint32_t y = scrut.v.fst;
        if (y < (uint32_t)65536U || y < (uint32_t)12U || (uint32_t)131072U < y)
          scrut1 =
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else
          scrut1 =
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = y, .snd = consumed_x + consumed_y }
              }
            );
      }
      else
        scrut1 =
          KRML_EABORT(FStar_Pervasives_Native_option__K___uint32_t_uint32_t,
            "unreachable (pattern matches are exhaustive in F*)");
    }
    else
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
  else
    scrut1 =
      KRML_EABORT(FStar_Pervasives_Native_option__K___uint32_t_uint32_t,
        "unreachable (pattern matches are exhaustive in F*)");
  FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t scrut2;
  if (scrut1.tag == FStar_Pervasives_Native_None)
    scrut2 =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (scrut1.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut1.v.snd;
    uint32_t sz = scrut1.v.fst;
    FStar_Bytes_bytes input_ = FStar_Bytes_slice(input, consumed, FStar_Bytes_len(input));
    FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t scrut0;
    if (FStar_Bytes_len(input_) < sz)
      scrut0 =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
    {
      bool b = true;
      KRML_CHECK_SIZE(sizeof (Prims_list__T13_t13), (uint32_t)1U);
      Prims_list__T13_t13 *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__T13_t13));
      buf0[0U] = ((Prims_list__T13_t13){ .tag = Prims_Nil });
      K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13
      x0 =
        {
          .fst = true,
          .snd = {
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = FStar_Bytes_slice(input_, (uint32_t)0U, sz), .snd = buf0 }
          }
        };
      while (b)
      {
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13 x = x0.snd;
        K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13 ite;
        if (x.tag == FStar_Pervasives_Native_Some)
        {
          Prims_list__T13_t13 *accu_ = x.v.snd;
          FStar_Bytes_bytes input_1 = x.v.fst;
          uint32_t len1 = FStar_Bytes_len(input_1);
          if (len1 == (uint32_t)0U)
            ite =
              (
                (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13){
                  .fst = false,
                  .snd = x
                }
              );
          else
          {
            FStar_Pervasives_Native_option__K___T13_t13_uint32_t scrut = T13_t13_parser32(input_1);
            if (scrut.tag == FStar_Pervasives_Native_Some)
            {
              uint32_t consumed1 = scrut.v.snd;
              T13_t13 v1 = scrut.v.fst;
              if (consumed1 == (uint32_t)0U)
                ite =
                  (
                    (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13){
                      .fst = false,
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  );
              else
              {
                FStar_Bytes_bytes input__ = FStar_Bytes_slice(input_1, consumed1, len1);
                KRML_CHECK_SIZE(sizeof (Prims_list__T13_t13), (uint32_t)1U);
                Prims_list__T13_t13 *buf = KRML_HOST_MALLOC(sizeof (Prims_list__T13_t13));
                buf[0U] = ((Prims_list__T13_t13){ .tag = Prims_Cons, .hd = v1, .tl = accu_ });
                ite =
                  (
                    (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13){
                      .fst = true,
                      .snd = {
                        .tag = FStar_Pervasives_Native_Some,
                        .v = { .fst = input__, .snd = buf }
                      }
                    }
                  );
              }
            }
            else if (scrut.tag == FStar_Pervasives_Native_None)
              ite =
                (
                  (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13){
                    .fst = false,
                    .snd = { .tag = FStar_Pervasives_Native_None }
                  }
                );
            else
              ite =
                KRML_EABORT(K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13,
                  "unreachable (pattern matches are exhaustive in F*)");
          }
        }
        else
          ite =
            KRML_EABORT(K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13,
              "unreachable (pattern matches are exhaustive in F*)");
        x0 = ite;
        b = x0.fst;
      }
      K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13
      scrut1 = x0;
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__T13_t13 accu = scrut1.snd;
      FStar_Pervasives_Native_option__Prims_list__T13_t13 scrut2;
      if (accu.tag == FStar_Pervasives_Native_None)
        scrut2 =
          (
            (FStar_Pervasives_Native_option__Prims_list__T13_t13){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (accu.tag == FStar_Pervasives_Native_Some)
      {
        Prims_list__T13_t13 *accu_ = accu.v.snd;
        scrut2 =
          (
            (FStar_Pervasives_Native_option__Prims_list__T13_t13){
              .tag = FStar_Pervasives_Native_Some,
              .v = LowParse_SLow_List_list_rev__T13_t13(accu_)
            }
          );
      }
      else
        scrut2 =
          KRML_EABORT(FStar_Pervasives_Native_option__Prims_list__T13_t13,
            "unreachable (pattern matches are exhaustive in F*)");
      FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t scrut;
      if (scrut2.tag == FStar_Pervasives_Native_None)
        scrut =
          (
            (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (scrut2.tag == FStar_Pervasives_Native_Some)
      {
        Prims_list__T13_t13 *res = scrut2.v;
        scrut =
          (
            (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = {
                .fst = res,
                .snd = FStar_Bytes_len(FStar_Bytes_slice(input_, (uint32_t)0U, sz))
              }
            }
          );
      }
      else
        scrut =
          KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t,
            "unreachable (pattern matches are exhaustive in F*)");
      if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed1 = scrut.v.snd;
        Prims_list__T13_t13 *v1 = scrut.v.fst;
        if (consumed1 == sz)
          scrut0 =
            (
              (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = v1, .snd = consumed1 }
              }
            );
        else
          scrut0 =
            (
              (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
      }
      else if (scrut.tag == FStar_Pervasives_Native_None)
        scrut0 =
          (
            (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else
        scrut0 =
          KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t,
            "unreachable (pattern matches are exhaustive in F*)");
    }
    FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t scrut;
    if (scrut0.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t consumed1 = scrut0.v.snd;
      Prims_list__T13_t13 *v1 = scrut0.v.fst;
      scrut =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = v1, .snd = consumed1 }
          }
        );
    }
    else if (scrut0.tag == FStar_Pervasives_Native_None)
      scrut =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
      scrut =
        KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t,
          "unreachable (pattern matches are exhaustive in F*)");
    if (scrut.tag == FStar_Pervasives_Native_None)
      scrut2 =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (scrut.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t consumed_ = scrut.v.snd;
      Prims_list__T13_t13 *x = scrut.v.fst;
      scrut2 =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = x, .snd = consumed + consumed_ }
          }
        );
    }
    else
      scrut2 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t,
          "unreachable (pattern matches are exhaustive in F*)");
  }
  else
    scrut2 =
      KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t,
        "unreachable (pattern matches are exhaustive in F*)");
  if (scrut2.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut2.v.snd;
    Prims_list__T13_t13 *v1 = scrut2.v.fst;
    return
      (
        (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = v1, .snd = consumed }
        }
      );
  }
  else
    return
      (
        (FStar_Pervasives_Native_option__K___Prims_list__T13_t13_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
}

FStar_Bytes_bytes T31_t31_serializer32(Prims_list__T13_t13 *input)
{
  Prims_list__T13_t13 *x0 = input;
  bool b = true;
  K___bool_K___FStar_Bytes_bytes_Prims_list__T13_t13
  x = { .fst = true, .snd = { .fst = FStar_Bytes_empty_bytes, .snd = x0 } };
  while (b)
  {
    K___FStar_Bytes_bytes_Prims_list__T13_t13 x1 = x.snd;
    FStar_Bytes_bytes accu = x1.fst;
    Prims_list__T13_t13 *input_ = x1.snd;
    K___bool_K___FStar_Bytes_bytes_Prims_list__T13_t13 ite;
    if (input_->tag == Prims_Nil)
      ite = ((K___bool_K___FStar_Bytes_bytes_Prims_list__T13_t13){ .fst = false, .snd = x1 });
    else if (input_->tag == Prims_Cons)
    {
      Prims_list__T13_t13 *q = input_->tl;
      T13_t13 a = input_->hd;
      FStar_Bytes_bytes sa = T13_t13_serializer32(a);
      FStar_Bytes_bytes accu_ = FStar_Bytes_append(accu, sa);
      ite =
        (
          (K___bool_K___FStar_Bytes_bytes_Prims_list__T13_t13){
            .fst = true,
            .snd = { .fst = accu_, .snd = q }
          }
        );
    }
    else
      ite =
        KRML_EABORT(K___bool_K___FStar_Bytes_bytes_Prims_list__T13_t13,
          "unreachable (pattern matches are exhaustive in F*)");
    x = ite;
    b = x.fst;
  }
  K___bool_K___FStar_Bytes_bytes_Prims_list__T13_t13 scrut = x;
  K___FStar_Bytes_bytes_Prims_list__T13_t13 scrut0 = scrut.snd;
  FStar_Bytes_bytes sp = scrut0.fst;
  uint32_t len1 = FStar_Bytes_len(sp);
  return FStar_Bytes_append(LowParse_SLow_BCVLI_serialize32_bcvli(len1), sp);
}

uint32_t T31_t31_size32(Prims_list__T13_t13 *input)
{
  bool b = true;
  K___bool_K___uint32_t_Prims_list__T13_t13
  x0 = { .fst = true, .snd = { .fst = (uint32_t)0U, .snd = input } };
  while (b)
  {
    K___uint32_t_Prims_list__T13_t13 x = x0.snd;
    uint32_t len1 = x.fst;
    Prims_list__T13_t13 *rem1 = x.snd;
    K___bool_K___uint32_t_Prims_list__T13_t13 ite;
    if (rem1->tag == Prims_Nil)
      ite = ((K___bool_K___uint32_t_Prims_list__T13_t13){ .fst = false, .snd = x });
    else if (rem1->tag == Prims_Cons)
    {
      Prims_list__T13_t13 *q = rem1->tl;
      T13_t13 a = rem1->hd;
      uint32_t sza = T13_t13_size32(a);
      uint32_t len_;
      if ((uint32_t)4294967295U - sza < len1)
        len_ = (uint32_t)4294967295U;
      else
        len_ = len1 + sza;
      if (len_ == (uint32_t)4294967295U)
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__T13_t13), (uint32_t)1U);
        Prims_list__T13_t13 *buf = KRML_HOST_MALLOC(sizeof (Prims_list__T13_t13));
        buf[0U] = ((Prims_list__T13_t13){ .tag = Prims_Nil });
        ite =
          (
            (K___bool_K___uint32_t_Prims_list__T13_t13){
              .fst = false,
              .snd = { .fst = (uint32_t)4294967295U, .snd = buf }
            }
          );
      }
      else
        ite =
          (
            (K___bool_K___uint32_t_Prims_list__T13_t13){
              .fst = true,
              .snd = { .fst = len_, .snd = q }
            }
          );
    }
    else
      ite =
        KRML_EABORT(K___bool_K___uint32_t_Prims_list__T13_t13,
          "unreachable (pattern matches are exhaustive in F*)");
    x0 = ite;
    b = x0.fst;
  }
  K___bool_K___uint32_t_Prims_list__T13_t13 scrut = x0;
  K___uint32_t_Prims_list__T13_t13 scrut0 = scrut.snd;
  uint32_t sp = scrut0.fst;
  return LowParse_SLow_BCVLI_size32_bcvli(sp) + sp;
}

uint32_t T31_t31_validator(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t
  n1 = LowParse_Low_BCVLI_validate_bounded_bcvli_((uint32_t)12U, (uint32_t)131072U, input, pos);
  if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < n1)
    return n1;
  else
  {
    uint32_t len1 = LowParse_Low_BCVLI_read_bcvli(input, pos);
    if (input.len - n1 < len1)
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
    else
    {
      uint32_t bpos = n1;
      while (true)
      {
        uint32_t pos1 = bpos;
        bool ite;
        if (pos1 == n1 + len1)
          ite = true;
        else
        {
          uint32_t
          pos11 =
            T13_t13_validator(((LowParse_Slice_slice){ .base = input.base, .len = n1 + len1 }),
              pos1);
          bpos = pos11;
          ite = pos11 > LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH;
        }
        if (ite)
          break;
      }
      uint32_t posf = bpos;
      uint32_t error = posf;
      uint32_t pos_;
      if (error <= LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH)
        pos_ = n1 + len1;
      else
        pos_ = error;
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos_)
        if (pos_ == LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos_;
      else
        return pos_;
    }
  }
}

uint32_t T31_t31_jumper(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t n1 = LowParse_Low_BCVLI_jump_bcvli(input, pos);
  uint32_t len1 = LowParse_Low_BCVLI_read_bcvli(input, pos);
  return n1 + len1;
}

