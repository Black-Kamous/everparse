/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -I ../../src/lowparse -skip-compilation -tmpdir ../unittests.snapshot -bundle LowParse.\* -drop FStar.Tactics.\* -drop FStar.Reflection.\* T10.fst T11.fst T11_z.fst T12.fst T12_z.fst T13.fst T13_x.fst T14.fst T14_x.fst T15_body.fst T15.fst T16.fst T16_x.fst T17.fst T17_x_a.fst T17_x_b.fst T18.fst T18_x_a.fst T18_x_b.fst T19.fst T1.fst T20.fst T21.fst T22_body_a.fst T22_body_b.fst T22.fst T23.fst T24.fst T24_y.fst T25_bpayload.fst T25.fst T25_payload.fst T26.fst T27.fst T28.fst T29.fst T2.fst T30.fst T31.fst T32.fst T33.fst T34.fst T35.fst T36.fst T3.fst T4.fst T5.fst T6.fst T6le.fst T7.fst T8.fst T8_z.fst T9_b.fst T9.fst Tag2.fst Tag.fst Tagle.fst -warn-error +9
  F* version: 74c6d2a5
  KreMLin version: 1bd260eb
 */

#include "LowParse.h"

extern uint32_t
LowParse_Low_BoundedInt_read_bounded_integer_le_1(LowParse_Slice_slice uu____7324, uint32_t x0);

extern uint32_t
LowParse_Low_BoundedInt_read_bounded_integer_le_2(LowParse_Slice_slice uu____7495, uint32_t x0);

extern uint32_t
LowParse_Low_BoundedInt_read_bounded_integer_le_4(LowParse_Slice_slice uu____7666, uint32_t x0);

uint32_t LowParse_Low_BCVLI_validate_bcvli(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t pos1;
  if (input.len - pos < (uint32_t)1U)
    pos1 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos1 = pos + (uint32_t)1U;
  if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos1)
    return pos1;
  else
  {
    uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
    if (r < (uint32_t)253U)
      return pos1;
    else if (r == (uint32_t)253U)
    {
      uint32_t pos2;
      if (input.len - pos1 < (uint32_t)2U)
        pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        pos2 = pos1 + (uint32_t)2U;
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
        return pos2;
      else
      {
        uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_2(input, pos1);
        if (r1 < (uint32_t)253U)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos2;
      }
    }
    else if (r == (uint32_t)254U)
    {
      uint32_t pos2;
      if (input.len - pos1 < (uint32_t)4U)
        pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        pos2 = pos1 + (uint32_t)4U;
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
        return pos2;
      else
      {
        uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_4(input, pos1);
        if (r1 < (uint32_t)65536U)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos2;
      }
    }
    else
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
  }
}

uint32_t LowParse_Low_BCVLI_jump_bcvli(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t pos1 = pos + (uint32_t)1U;
  uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
  if (r < (uint32_t)253U)
    return pos1;
  else if (r == (uint32_t)253U)
    return pos1 + (uint32_t)2U;
  else
    return pos1 + (uint32_t)4U;
}

uint32_t LowParse_Low_BCVLI_read_bcvli(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
  if (r < (uint32_t)253U)
    return r;
  else
  {
    uint32_t pos1 = pos + (uint32_t)1U;
    if (r == (uint32_t)253U)
      return LowParse_Low_BoundedInt_read_bounded_integer_le_2(input, pos1);
    else
      return LowParse_Low_BoundedInt_read_bounded_integer_le_4(input, pos1);
  }
}

uint32_t
LowParse_Low_BCVLI_validate_bounded_bcvli_(
  uint32_t min32,
  uint32_t max32,
  LowParse_Slice_slice input,
  uint32_t pos
)
{
  uint32_t pos1;
  if (input.len - pos < (uint32_t)1U)
    pos1 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos1 = pos + (uint32_t)1U;
  if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos1)
    return pos1;
  else
  {
    uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
    if (r < (uint32_t)253U && min32 <= r && r <= max32)
      return pos1;
    else if (max32 < (uint32_t)253U)
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
    else if (r == (uint32_t)253U)
      if ((uint32_t)65536U <= min32)
        return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
      else
      {
        uint32_t pos2;
        if (input.len - pos1 < (uint32_t)2U)
          pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
        else
          pos2 = pos1 + (uint32_t)2U;
        if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
          return pos2;
        else
        {
          uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_2(input, pos1);
          if (r1 < (uint32_t)253U || r1 < min32 || max32 < r1)
            return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
          else
            return pos2;
        }
      }
    else if (max32 < (uint32_t)65536U)
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
    else if (r == (uint32_t)254U)
    {
      uint32_t pos2;
      if (input.len - pos1 < (uint32_t)4U)
        pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        pos2 = pos1 + (uint32_t)4U;
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
        return pos2;
      else
      {
        uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_4(input, pos1);
        if (r1 < (uint32_t)65536U || r1 < min32 || max32 < r1)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos2;
      }
    }
    else
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
  }
}

