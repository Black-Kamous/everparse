/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: /home/tahina/everest/master/kremlin/krml -ccopt -Ofast -drop FStar.Tactics.\* -drop FStar.Tactics -drop FStar.Reflection.\* -tmpdir out -I .. -bundle LowParse.\* -add-include "kremlin/internal/compat.h" -warn-error -9 ../../src/lowparse/LowParse_TestLib_Low_c.c -no-prefix Test kremlin/FStar_Pervasives_Native.krml kremlin/FStar_Pervasives.krml kremlin/FStar_Preorder.krml kremlin/FStar_Calc.krml kremlin/FStar_Squash.krml kremlin/FStar_Classical.krml kremlin/FStar_StrongExcludedMiddle.krml kremlin/FStar_FunctionalExtensionality.krml kremlin/FStar_List_Tot_Base.krml kremlin/FStar_List_Tot_Properties.krml kremlin/FStar_List_Tot.krml kremlin/FStar_Seq_Base.krml kremlin/FStar_Seq_Properties.krml kremlin/FStar_Seq.krml kremlin/FStar_Mul.krml kremlin/FStar_Math_Lib.krml kremlin/FStar_Math_Lemmas.krml kremlin/FStar_BitVector.krml kremlin/FStar_UInt.krml kremlin/FStar_UInt32.krml kremlin/FStar_Int.krml kremlin/FStar_Int16.krml kremlin/FStar_Range.krml kremlin/FStar_Reflection_Types.krml kremlin/FStar_Tactics_Types.krml kremlin/FStar_Tactics_Result.krml kremlin/FStar_Tactics_Effect.krml kremlin/FStar_Tactics_Util.krml kremlin/FStar_Reflection_Data.krml kremlin/FStar_Reflection_Const.krml kremlin/FStar_Char.krml kremlin/FStar_Exn.krml kremlin/FStar_Set.krml kremlin/FStar_Monotonic_Witnessed.krml kremlin/FStar_Ghost.krml kremlin/FStar_ErasedLogic.krml kremlin/FStar_PropositionalExtensionality.krml kremlin/FStar_PredicateExtensionality.krml kremlin/FStar_TSet.krml kremlin/FStar_Monotonic_Heap.krml kremlin/FStar_Heap.krml kremlin/FStar_ST.krml kremlin/FStar_All.krml kremlin/FStar_List.krml kremlin/FStar_String.krml kremlin/FStar_Order.krml kremlin/FStar_Reflection_Basic.krml kremlin/FStar_Reflection_Derived.krml kremlin/FStar_Tactics_Builtins.krml kremlin/FStar_Reflection_Formula.krml kremlin/FStar_Reflection_Derived_Lemmas.krml kremlin/FStar_Reflection.krml kremlin/FStar_Tactics_Derived.krml kremlin/FStar_Tactics_Logic.krml kremlin/FStar_Tactics.krml kremlin/FStar_Map.krml kremlin/FStar_Monotonic_HyperHeap.krml kremlin/FStar_Monotonic_HyperStack.krml kremlin/FStar_HyperStack.krml kremlin/FStar_HyperStack_ST.krml kremlin/FStar_Universe.krml kremlin/FStar_GSet.krml kremlin/FStar_ModifiesGen.krml kremlin/FStar_BigOps.krml kremlin/LowStar_Monotonic_Buffer.krml kremlin/LowStar_Buffer.krml kremlin/FStar_UInt8.krml kremlin/LowParse_Bytes.krml kremlin/LowParse_Spec_Base.krml kremlin/LowParse_Spec_Combinators.krml kremlin/LowParse_Spec_FLData.krml kremlin/Spec_Loops.krml kremlin/FStar_UInt64.krml kremlin/LowStar_BufferOps.krml kremlin/C_Loops.krml kremlin/LowParse_Math.krml kremlin/LowParse_Slice.krml kremlin/LowParse_Low_Base.krml kremlin/LowParse_Low_Combinators.krml kremlin/LowParse_Low_FLData.krml kremlin/FStar_Int64.krml kremlin/FStar_Int63.krml kremlin/FStar_Int32.krml kremlin/FStar_Int8.krml kremlin/FStar_UInt63.krml kremlin/FStar_UInt16.krml kremlin/FStar_Int_Cast.krml kremlin/FStar_HyperStack_All.krml kremlin/FStar_Kremlin_Endianness.krml kremlin/LowParse_BigEndian.krml kremlin/LowParse_Spec_Int_Aux.krml kremlin/LowParse_Spec_Int.krml kremlin/LowParse_Spec_BoundedInt.krml kremlin/LowStar_Modifies.krml kremlin/LowStar_ModifiesPat.krml kremlin/LowParse_BigEndianImpl_Base.krml kremlin/LowParse_BigEndianImpl_Low.krml kremlin/LowParse_Low_BoundedInt.krml kremlin/LowParse_Spec_SeqBytes_Base.krml kremlin/LowParse_Spec_DER.krml kremlin/LowParse_Spec_BCVLI.krml kremlin/LowParse_Spec_AllIntegers.krml kremlin/LowParse_Spec_VLData.krml kremlin/LowParse_Low_VLData.krml kremlin/LowParse_Spec_VLGen.krml kremlin/LowParse_Low_VLGen.krml kremlin/LowParse_Spec_Int_Unique.krml kremlin/LowParse_Low_Int_Aux.krml kremlin/LowParse_Low_Int.krml kremlin/LowParse_Low_DER.krml kremlin/LowParse_Low_BCVLI.krml kremlin/LowParse_Spec_List.krml kremlin/LowParse_Low_List.krml kremlin/LowParse_Spec_Array.krml kremlin/LowParse_Spec_VCList.krml kremlin/LowParse_Low_VCList.krml kremlin/LowParse_Spec_IfThenElse.krml kremlin/LowParse_Low_IfThenElse.krml kremlin/LowParse_TacLib.krml kremlin/LowParse_Spec_Enum.krml kremlin/LowParse_Spec_Sum.krml kremlin/LowParse_Low_Enum.krml kremlin/LowParse_Low_Sum.krml kremlin/LowParse_Low_Tac_Sum.krml kremlin/LowParse_Spec_Option.krml kremlin/LowParse_Low_Option.krml kremlin/FStar_Bytes.krml kremlin/LowParse_Bytes32.krml kremlin/LowParse_Spec_Bytes.krml kremlin/LowParse_Low_Bytes.krml kremlin/LowParse_Low_Array.krml kremlin/LowParse_Low.krml kremlin/LowParse_SLow_Base.krml kremlin/LowParse_SLow_Combinators.krml kremlin/LowParse_SLow_FLData.krml kremlin/LowParse_SLow_VLGen.krml kremlin/LowParse_BigEndianImpl_SLow.krml kremlin/LowParse_SLow_BoundedInt.krml kremlin/LowParse_SLow_Int_Aux.krml kremlin/LowParse_SLow_Int.krml kremlin/LowParse_SLow_DER.krml kremlin/LowParse_SLow_BCVLI.krml kremlin/LowParse_SLow_List.krml kremlin/LowParse_SLow_VCList.krml kremlin/LowParse_SLow_IfThenElse.krml kremlin/LowParse_SLow_Option.krml kremlin/LowParse_SLow_Enum.krml kremlin/LowParse_SLow_Sum.krml kremlin/LowParse_SLow_Tac_Enum.krml kremlin/LowParse_SLow_Tac_Sum.krml kremlin/LowParse_SLow_VLData.krml kremlin/LowParse_SLow_Bytes.krml kremlin/LowParse_SLow_Array.krml kremlin/LowParse_Spec_Tac_Combinators.krml kremlin/LowParse_SLow.krml kremlin/Tag2.krml kremlin/T15_body.krml kremlin/T3.krml kremlin/T5.krml kremlin/T9_b.krml kremlin/Amount.krml kremlin/Txout_scriptPubKey.krml kremlin/Txout.krml kremlin/Transaction_outputs.krml kremlin/Txin_scriptSig.krml kremlin/Sha256.krml kremlin/Txin.krml kremlin/Transaction_inputs.krml kremlin/Transaction.krml kremlin/Block_tx.krml kremlin/Block.krml kremlin/T25_bpayload.krml kremlin/FStar_Int128.krml kremlin/FStar_Int31.krml kremlin/FStar_UInt128.krml kremlin/FStar_UInt31.krml kremlin/FStar_Integers.krml kremlin/FStar_Printf.krml kremlin/Tagle.krml kremlin/T4.krml kremlin/T6le.krml kremlin/T24_y.krml kremlin/T24.krml kremlin/T25_payload.krml kremlin/T25.krml kremlin/T14_x.krml kremlin/T13_x.krml kremlin/T13.krml kremlin/T18_x_b.krml kremlin/T20.krml kremlin/T21.krml kremlin/C_Endianness.krml kremlin/C.krml kremlin/C_String.krml kremlin/T26.krml kremlin/Tag.krml kremlin/T16_x.krml kremlin/T16.krml kremlin/LowStar_ImmutableBuffer.krml kremlin/FStar_HyperStack_IO.krml kremlin/LowParse_TestLib_Low.krml kremlin/T18_x_a.krml kremlin/T33.krml kremlin/T19.krml kremlin/T1.krml kremlin/T17_x_b.krml kremlin/T22_body_b.krml kremlin/T12_z.krml kremlin/T12.krml kremlin/T2.krml kremlin/T7.krml kremlin/T8_z.krml kremlin/T27.krml kremlin/T14.krml kremlin/T32.krml kremlin/T29.krml kremlin/T36.krml kremlin/T10.krml kremlin/T17_x_a.krml kremlin/T17.krml kremlin/T15.krml kremlin/T35.krml kremlin/T22_body_a.krml kremlin/FStar_Float.krml kremlin/FStar_IO.krml kremlin/T18.krml kremlin/T23.krml kremlin/T9.krml kremlin/T8.krml kremlin/T28.krml kremlin/T6.krml kremlin/Test.krml kremlin/T30.krml kremlin/T11_z.krml kremlin/T34.krml kremlin/T11.krml kremlin/T31.krml kremlin/T22.krml -o test.exe
  F* version: 74c6d2a5
  KreMLin version: 1bd260eb
 */

#include "LowParse.h"

uint32_t LowParse_Low_BoundedInt_read_bounded_integer_1(LowParse_Slice_slice sl, uint32_t pos)
{
  uint8_t b = sl.base[pos + (uint32_t)0U];
  uint32_t accu256 = (uint32_t)0U;
  return (uint32_t)b + accu256;
}

uint32_t LowParse_Low_BoundedInt_read_bounded_integer_2(LowParse_Slice_slice sl, uint32_t pos)
{
  uint8_t b0 = sl.base[pos + (uint32_t)0U];
  uint32_t accu2560 = (uint32_t)0U;
  uint32_t res2 = (uint32_t)b0 + accu2560;
  uint8_t b = sl.base[pos + (uint32_t)1U];
  uint32_t accu256 = res2 * (uint32_t)256U;
  return (uint32_t)b + accu256;
}

uint32_t LowParse_Low_BoundedInt_read_bounded_integer_3(LowParse_Slice_slice sl, uint32_t pos)
{
  uint8_t b0 = sl.base[pos + (uint32_t)0U];
  uint32_t accu2560 = (uint32_t)0U;
  uint32_t res3 = (uint32_t)b0 + accu2560;
  uint8_t b1 = sl.base[pos + (uint32_t)1U];
  uint32_t accu2561 = res3 * (uint32_t)256U;
  uint32_t res2 = (uint32_t)b1 + accu2561;
  uint8_t b = sl.base[pos + (uint32_t)2U];
  uint32_t accu256 = res2 * (uint32_t)256U;
  return (uint32_t)b + accu256;
}

uint32_t LowParse_Low_BoundedInt_read_bounded_integer_4(LowParse_Slice_slice sl, uint32_t pos)
{
  uint8_t b0 = sl.base[pos + (uint32_t)0U];
  uint32_t accu2560 = (uint32_t)0U;
  uint32_t res4 = (uint32_t)b0 + accu2560;
  uint8_t b1 = sl.base[pos + (uint32_t)1U];
  uint32_t accu2561 = res4 * (uint32_t)256U;
  uint32_t res3 = (uint32_t)b1 + accu2561;
  uint8_t b2 = sl.base[pos + (uint32_t)2U];
  uint32_t accu2562 = res3 * (uint32_t)256U;
  uint32_t res2 = (uint32_t)b2 + accu2562;
  uint8_t b = sl.base[pos + (uint32_t)3U];
  uint32_t accu256 = res2 * (uint32_t)256U;
  return (uint32_t)b + accu256;
}

static uint32_t
LowParse_Low_BoundedInt_read_bounded_integer_le_1(LowParse_Slice_slice sl, uint32_t pos)
{
  uint8_t r = sl.base[pos];
  return (uint32_t)r;
}

static uint32_t
LowParse_Low_BoundedInt_read_bounded_integer_le_2(LowParse_Slice_slice sl, uint32_t pos)
{
  uint8_t r0 = sl.base[pos];
  uint8_t r1 = sl.base[pos + (uint32_t)1U];
  return (uint32_t)r0 + (uint32_t)256U * (uint32_t)r1;
}

static uint32_t
LowParse_Low_BoundedInt_read_bounded_integer_le_4(LowParse_Slice_slice sl, uint32_t pos)
{
  uint8_t r0 = sl.base[pos];
  uint8_t r1 = sl.base[pos + (uint32_t)1U];
  uint8_t r2 = sl.base[pos + (uint32_t)2U];
  uint8_t r3 = sl.base[pos + (uint32_t)3U];
  return
    (uint32_t)r0
    +
      (uint32_t)256U
      * ((uint32_t)r1 + (uint32_t)256U * ((uint32_t)r2 + (uint32_t)256U * (uint32_t)r3));
}

uint8_t LowParse_Low_Int_read_u8(LowParse_Slice_slice sl, uint32_t pos)
{
  return sl.base[pos];
}

uint32_t LowParse_Low_Int_write_u8(uint8_t x, LowParse_Slice_slice input, uint32_t pos)
{
  input.base[pos] = x;
  uint32_t len = (uint32_t)1U;
  return pos + len;
}

uint32_t LowParse_Low_BCVLI_validate_bcvli(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t pos1;
  if (input.len - pos < (uint32_t)1U)
    pos1 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos1 = pos + (uint32_t)1U;
  if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos1)
    return pos1;
  else
  {
    uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
    if (r < (uint32_t)253U)
      return pos1;
    else if (r == (uint32_t)253U)
    {
      uint32_t pos2;
      if (input.len - pos1 < (uint32_t)2U)
        pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        pos2 = pos1 + (uint32_t)2U;
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
        return pos2;
      else
      {
        uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_2(input, pos1);
        if (r1 < (uint32_t)253U)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos2;
      }
    }
    else if (r == (uint32_t)254U)
    {
      uint32_t pos2;
      if (input.len - pos1 < (uint32_t)4U)
        pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        pos2 = pos1 + (uint32_t)4U;
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
        return pos2;
      else
      {
        uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_4(input, pos1);
        if (r1 < (uint32_t)65536U)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos2;
      }
    }
    else
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
  }
}

uint32_t LowParse_Low_BCVLI_jump_bcvli(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t pos1 = pos + (uint32_t)1U;
  uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
  if (r < (uint32_t)253U)
    return pos1;
  else if (r == (uint32_t)253U)
    return pos1 + (uint32_t)2U;
  else
    return pos1 + (uint32_t)4U;
}

uint32_t LowParse_Low_BCVLI_read_bcvli(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
  if (r < (uint32_t)253U)
    return r;
  else
  {
    uint32_t pos1 = pos + (uint32_t)1U;
    if (r == (uint32_t)253U)
      return LowParse_Low_BoundedInt_read_bounded_integer_le_2(input, pos1);
    else
      return LowParse_Low_BoundedInt_read_bounded_integer_le_4(input, pos1);
  }
}

uint32_t
LowParse_Low_BCVLI_validate_bounded_bcvli_(
  uint32_t min32,
  uint32_t max32,
  LowParse_Slice_slice input,
  uint32_t pos
)
{
  uint32_t pos1;
  if (input.len - pos < (uint32_t)1U)
    pos1 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos1 = pos + (uint32_t)1U;
  if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos1)
    return pos1;
  else
  {
    uint32_t r = LowParse_Low_BoundedInt_read_bounded_integer_le_1(input, pos);
    if (r < (uint32_t)253U && min32 <= r && r <= max32)
      return pos1;
    else if (max32 < (uint32_t)253U)
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
    else if (r == (uint32_t)253U)
      if ((uint32_t)65536U <= min32)
        return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
      else
      {
        uint32_t pos2;
        if (input.len - pos1 < (uint32_t)2U)
          pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
        else
          pos2 = pos1 + (uint32_t)2U;
        if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
          return pos2;
        else
        {
          uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_2(input, pos1);
          if (r1 < (uint32_t)253U || r1 < min32 || max32 < r1)
            return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
          else
            return pos2;
        }
      }
    else if (max32 < (uint32_t)65536U)
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
    else if (r == (uint32_t)254U)
    {
      uint32_t pos2;
      if (input.len - pos1 < (uint32_t)4U)
        pos2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        pos2 = pos1 + (uint32_t)4U;
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos2)
        return pos2;
      else
      {
        uint32_t r1 = LowParse_Low_BoundedInt_read_bounded_integer_le_4(input, pos1);
        if (r1 < (uint32_t)65536U || r1 < min32 || max32 < r1)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos2;
      }
    }
    else
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
  }
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BoundedInt_parse32_bounded_integer_1(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)1U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)1U);
    uint8_t b = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)1U);
    uint32_t accu256 = (uint32_t)0U;
    uint32_t res = (uint32_t)b + accu256;
    uint32_t r = res;
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = r, .snd = (uint32_t)1U }
        }
      );
  }
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BoundedInt_parse32_bounded_integer_2(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)2U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)2U);
    uint8_t b0 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)2U);
    uint32_t accu2560 = (uint32_t)0U;
    uint32_t res2 = (uint32_t)b0 + accu2560;
    uint8_t b = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)1U);
    uint32_t accu256 = res2 * (uint32_t)256U;
    uint32_t res1 = (uint32_t)b + accu256;
    uint32_t r = res1;
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = r, .snd = (uint32_t)2U }
        }
      );
  }
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BoundedInt_parse32_bounded_integer_3(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)3U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)3U);
    uint8_t b0 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)3U);
    uint32_t accu2560 = (uint32_t)0U;
    uint32_t res3 = (uint32_t)b0 + accu2560;
    uint8_t b1 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)2U);
    uint32_t accu2561 = res3 * (uint32_t)256U;
    uint32_t res2 = (uint32_t)b1 + accu2561;
    uint8_t b = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)1U);
    uint32_t accu256 = res2 * (uint32_t)256U;
    uint32_t res1 = (uint32_t)b + accu256;
    uint32_t r = res1;
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = r, .snd = (uint32_t)3U }
        }
      );
  }
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BoundedInt_parse32_bounded_integer_4(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)4U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)4U);
    uint8_t b0 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)4U);
    uint32_t accu2560 = (uint32_t)0U;
    uint32_t res4 = (uint32_t)b0 + accu2560;
    uint8_t b1 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)3U);
    uint32_t accu2561 = res4 * (uint32_t)256U;
    uint32_t res3 = (uint32_t)b1 + accu2561;
    uint8_t b2 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)2U);
    uint32_t accu2562 = res3 * (uint32_t)256U;
    uint32_t res2 = (uint32_t)b2 + accu2562;
    uint8_t b = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)1U);
    uint32_t accu256 = res2 * (uint32_t)256U;
    uint32_t res1 = (uint32_t)b + accu256;
    uint32_t r = res1;
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = r, .snd = (uint32_t)4U }
        }
      );
  }
}

FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_bounded_integer_1(uint32_t input)
{
  FStar_Bytes_bytes accu = FStar_Bytes_empty_bytes;
  uint8_t b = (uint8_t)input;
  FStar_Bytes_bytes accu_ = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b), accu);
  FStar_Bytes_bytes res = accu_;
  FStar_Bytes_bytes b0 = res;
  return b0;
}

FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_bounded_integer_2(uint32_t input)
{
  FStar_Bytes_bytes accu = FStar_Bytes_empty_bytes;
  uint8_t b = (uint8_t)input;
  FStar_Bytes_bytes accu_ = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b), accu);
  FStar_Bytes_bytes accu1 = accu_;
  uint32_t x1 = input / (uint32_t)256U;
  uint8_t b0 = (uint8_t)x1;
  FStar_Bytes_bytes accu_0 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b0), accu1);
  FStar_Bytes_bytes res = accu_0;
  FStar_Bytes_bytes b1 = res;
  return b1;
}

FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_bounded_integer_3(uint32_t input)
{
  FStar_Bytes_bytes accu = FStar_Bytes_empty_bytes;
  uint8_t b0 = (uint8_t)input;
  FStar_Bytes_bytes accu_ = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b0), accu);
  FStar_Bytes_bytes accu2 = accu_;
  uint32_t x2 = input / (uint32_t)256U;
  uint8_t b = (uint8_t)x2;
  FStar_Bytes_bytes accu_0 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b), accu2);
  FStar_Bytes_bytes accu1 = accu_0;
  uint32_t x1 = x2 / (uint32_t)256U;
  uint8_t b1 = (uint8_t)x1;
  FStar_Bytes_bytes accu_1 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b1), accu1);
  FStar_Bytes_bytes res = accu_1;
  FStar_Bytes_bytes b2 = res;
  return b2;
}

FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_bounded_integer_4(uint32_t input)
{
  FStar_Bytes_bytes accu = FStar_Bytes_empty_bytes;
  uint8_t b0 = (uint8_t)input;
  FStar_Bytes_bytes accu_ = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b0), accu);
  FStar_Bytes_bytes accu3 = accu_;
  uint32_t x3 = input / (uint32_t)256U;
  uint8_t b1 = (uint8_t)x3;
  FStar_Bytes_bytes accu_0 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b1), accu3);
  FStar_Bytes_bytes accu2 = accu_0;
  uint32_t x2 = x3 / (uint32_t)256U;
  uint8_t b = (uint8_t)x2;
  FStar_Bytes_bytes accu_1 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b), accu2);
  FStar_Bytes_bytes accu1 = accu_1;
  uint32_t x1 = x2 / (uint32_t)256U;
  uint8_t b2 = (uint8_t)x1;
  FStar_Bytes_bytes accu_2 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b2), accu1);
  FStar_Bytes_bytes res = accu_2;
  FStar_Bytes_bytes b3 = res;
  return b3;
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BoundedInt_parse32_bounded_integer_le_1(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)1U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)1U);
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = (uint32_t)FStar_Bytes_get(s_, (uint32_t)0U), .snd = (uint32_t)1U }
        }
      );
  }
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BoundedInt_parse32_bounded_integer_le_2(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)2U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)2U);
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .fst = (uint32_t)FStar_Bytes_get(s_, (uint32_t)0U)
            + (uint32_t)256U * (uint32_t)FStar_Bytes_get(s_, (uint32_t)1U),
            .snd = (uint32_t)2U
          }
        }
      );
  }
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BoundedInt_parse32_bounded_integer_le_4(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)4U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)4U);
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .fst = (uint32_t)FStar_Bytes_get(s_, (uint32_t)0U)
            +
              (uint32_t)256U
              *
                ((uint32_t)FStar_Bytes_get(s_, (uint32_t)1U)
                +
                  (uint32_t)256U
                  *
                    ((uint32_t)FStar_Bytes_get(s_, (uint32_t)2U)
                    + (uint32_t)256U * (uint32_t)FStar_Bytes_get(s_, (uint32_t)3U))),
            .snd = (uint32_t)4U
          }
        }
      );
  }
}

FStar_Pervasives_Native_option__K___uint16_t_uint32_t
LowParse_SLow_BoundedInt_parse32_u16_le(FStar_Bytes_bytes input)
{
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t scrut;
  if (FStar_Bytes_len(input) < (uint32_t)2U)
    scrut =
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)2U);
    scrut =
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .fst = (uint32_t)FStar_Bytes_get(s_, (uint32_t)0U)
            + (uint32_t)256U * (uint32_t)FStar_Bytes_get(s_, (uint32_t)1U),
            .snd = (uint32_t)2U
          }
        }
      );
  }
  if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut.v.snd;
    uint32_t v1 = scrut.v.fst;
    return
      (
        (FStar_Pervasives_Native_option__K___uint16_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = (uint16_t)v1, .snd = consumed }
        }
      );
  }
  else
    return
      (
        (FStar_Pervasives_Native_option__K___uint16_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
}

static FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_bounded_integer_le_1(uint32_t x)
{
  return FStar_Bytes_create((uint32_t)1U, (uint8_t)x);
}

static FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_bounded_integer_le_2(uint32_t x)
{
  return
    FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, (uint8_t)x),
      FStar_Bytes_create((uint32_t)1U, (uint8_t)(x / (uint32_t)256U)));
}

static FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_bounded_integer_le_4(uint32_t x)
{
  uint8_t rem0 = (uint8_t)x;
  uint32_t div0 = x / (uint32_t)256U;
  uint8_t rem1 = (uint8_t)div0;
  uint32_t div1 = div0 / (uint32_t)256U;
  uint8_t rem2 = (uint8_t)div1;
  uint32_t div2 = div1 / (uint32_t)256U;
  uint8_t rem3 = (uint8_t)div2;
  return
    FStar_Bytes_append(FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, rem0),
        FStar_Bytes_create((uint32_t)1U, rem1)),
      FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, rem2),
        FStar_Bytes_create((uint32_t)1U, rem3)));
}

FStar_Bytes_bytes LowParse_SLow_BoundedInt_serialize32_u16_le(uint16_t input)
{
  uint32_t x = (uint32_t)input;
  return
    FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, (uint8_t)x),
      FStar_Bytes_create((uint32_t)1U, (uint8_t)(x / (uint32_t)256U)));
}

FStar_Pervasives_Native_option__K___uint8_t_uint32_t
LowParse_SLow_Int_parse32_u8(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)1U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint8_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)1U);
    uint8_t r = FStar_Bytes_get(s_, (uint32_t)0U);
    return
      (
        (FStar_Pervasives_Native_option__K___uint8_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = r, .snd = (uint32_t)1U }
        }
      );
  }
}

FStar_Bytes_bytes LowParse_SLow_Int_serialize32_u8(uint8_t input)
{
  FStar_Bytes_bytes b = FStar_Bytes_create((uint32_t)1U, input);
  return b;
}

FStar_Pervasives_Native_option__K___uint16_t_uint32_t
LowParse_SLow_Int_parse32_u16(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)2U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint16_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)2U);
    uint8_t b0 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)2U);
    uint16_t accu2560 = (uint16_t)0U;
    uint16_t res2 = (uint16_t)b0 + accu2560;
    uint8_t b = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)1U);
    uint16_t accu256 = res2 * (uint16_t)256U;
    uint16_t res1 = (uint16_t)b + accu256;
    uint16_t res = res1;
    return
      (
        (FStar_Pervasives_Native_option__K___uint16_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = res, .snd = (uint32_t)2U }
        }
      );
  }
}

FStar_Bytes_bytes LowParse_SLow_Int_serialize32_u16(uint16_t input)
{
  FStar_Bytes_bytes accu = FStar_Bytes_empty_bytes;
  uint8_t b = (uint8_t)input;
  FStar_Bytes_bytes accu_ = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b), accu);
  FStar_Bytes_bytes accu1 = accu_;
  uint16_t x1 = input / (uint16_t)256U;
  uint8_t b0 = (uint8_t)x1;
  FStar_Bytes_bytes accu_0 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b0), accu1);
  FStar_Bytes_bytes res = accu_0;
  FStar_Bytes_bytes b1 = res;
  return b1;
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_Int_parse32_u32(FStar_Bytes_bytes input)
{
  if (FStar_Bytes_len(input) < (uint32_t)4U)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    FStar_Bytes_bytes s_ = FStar_Bytes_slice(input, (uint32_t)0U, (uint32_t)4U);
    uint8_t b0 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)4U);
    uint32_t accu2560 = (uint32_t)0U;
    uint32_t res4 = (uint32_t)b0 + accu2560;
    uint8_t b1 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)3U);
    uint32_t accu2561 = res4 * (uint32_t)256U;
    uint32_t res3 = (uint32_t)b1 + accu2561;
    uint8_t b2 = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)2U);
    uint32_t accu2562 = res3 * (uint32_t)256U;
    uint32_t res2 = (uint32_t)b2 + accu2562;
    uint8_t b = FStar_Bytes_get(s_, FStar_Bytes_len(s_) - (uint32_t)1U);
    uint32_t accu256 = res2 * (uint32_t)256U;
    uint32_t res1 = (uint32_t)b + accu256;
    uint32_t res = res1;
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = res, .snd = (uint32_t)4U }
        }
      );
  }
}

FStar_Bytes_bytes LowParse_SLow_Int_serialize32_u32(uint32_t input)
{
  FStar_Bytes_bytes accu = FStar_Bytes_empty_bytes;
  uint8_t b0 = (uint8_t)input;
  FStar_Bytes_bytes accu_ = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b0), accu);
  FStar_Bytes_bytes accu3 = accu_;
  uint32_t x3 = input / (uint32_t)256U;
  uint8_t b1 = (uint8_t)x3;
  FStar_Bytes_bytes accu_0 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b1), accu3);
  FStar_Bytes_bytes accu2 = accu_0;
  uint32_t x2 = x3 / (uint32_t)256U;
  uint8_t b = (uint8_t)x2;
  FStar_Bytes_bytes accu_1 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b), accu2);
  FStar_Bytes_bytes accu1 = accu_1;
  uint32_t x1 = x2 / (uint32_t)256U;
  uint8_t b2 = (uint8_t)x1;
  FStar_Bytes_bytes accu_2 = FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, b2), accu1);
  FStar_Bytes_bytes res = accu_2;
  FStar_Bytes_bytes b3 = res;
  return b3;
}

FStar_Pervasives_Native_option__K___uint32_t_uint32_t
LowParse_SLow_BCVLI_parse32_bcvli(FStar_Bytes_bytes input)
{
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t
  scrut = LowParse_SLow_BoundedInt_parse32_bounded_integer_le_1(input);
  if (scrut.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed_x = scrut.v.snd;
    uint32_t x32 = scrut.v.fst;
    if (x32 < (uint32_t)253U)
      return
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = x32, .snd = consumed_x }
          }
        );
    else
    {
      FStar_Bytes_bytes input_ = FStar_Bytes_slice(input, consumed_x, FStar_Bytes_len(input));
      if (x32 == (uint32_t)253U)
      {
        FStar_Pervasives_Native_option__K___uint32_t_uint32_t
        scrut = LowParse_SLow_BoundedInt_parse32_bounded_integer_le_2(input_);
        if (scrut.tag == FStar_Pervasives_Native_None)
          return
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed_y = scrut.v.snd;
          uint32_t y = scrut.v.fst;
          if (y < (uint32_t)253U)
            return
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
          else
            return
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { .fst = y, .snd = consumed_x + consumed_y }
                }
              );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else if (x32 == (uint32_t)254U)
      {
        FStar_Pervasives_Native_option__K___uint32_t_uint32_t
        scrut = LowParse_SLow_BoundedInt_parse32_bounded_integer_le_4(input_);
        if (scrut.tag == FStar_Pervasives_Native_None)
          return
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed_y = scrut.v.snd;
          uint32_t y = scrut.v.fst;
          if (y < (uint32_t)65536U)
            return
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
          else
            return
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { .fst = y, .snd = consumed_x + consumed_y }
                }
              );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
        return
          (
            (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes LowParse_SLow_BCVLI_serialize32_bcvli(uint32_t x)
{
  uint32_t c1;
  if (x < (uint32_t)253U)
    c1 = x;
  else if (x < (uint32_t)65536U)
    c1 = (uint32_t)253U;
  else
    c1 = (uint32_t)254U;
  FStar_Bytes_bytes s1 = LowParse_SLow_BoundedInt_serialize32_bounded_integer_le_1(c1);
  if (c1 < (uint32_t)253U)
    return s1;
  else if (c1 == (uint32_t)253U)
    return FStar_Bytes_append(s1, LowParse_SLow_BoundedInt_serialize32_bounded_integer_le_2(x));
  else
    return FStar_Bytes_append(s1, LowParse_SLow_BoundedInt_serialize32_bounded_integer_le_4(x));
}

uint32_t LowParse_SLow_BCVLI_size32_bcvli(uint32_t x)
{
  if (x < (uint32_t)253U)
    return (uint32_t)1U;
  else if (x < (uint32_t)65536U)
    return (uint32_t)3U;
  else
    return (uint32_t)5U;
}

