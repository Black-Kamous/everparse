/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: /home/tahina/everest/master/kremlin/krml -ccopt -Ofast -drop FStar.Tactics.\* -drop FStar.Tactics -drop FStar.Reflection.\* -tmpdir out -I .. -bundle LowParse.\* -add-include "kremlin/internal/compat.h" -warn-error -9 ../../src/lowparse/LowParse_TestLib_Low_c.c -no-prefix Test kremlin/FStar_Pervasives_Native.krml kremlin/FStar_Pervasives.krml kremlin/FStar_Preorder.krml kremlin/FStar_Calc.krml kremlin/FStar_Squash.krml kremlin/FStar_Classical.krml kremlin/FStar_StrongExcludedMiddle.krml kremlin/FStar_FunctionalExtensionality.krml kremlin/FStar_List_Tot_Base.krml kremlin/FStar_List_Tot_Properties.krml kremlin/FStar_List_Tot.krml kremlin/FStar_Seq_Base.krml kremlin/FStar_Seq_Properties.krml kremlin/FStar_Seq.krml kremlin/FStar_Mul.krml kremlin/FStar_Math_Lib.krml kremlin/FStar_Math_Lemmas.krml kremlin/FStar_BitVector.krml kremlin/FStar_UInt.krml kremlin/FStar_UInt32.krml kremlin/FStar_Int.krml kremlin/FStar_Int16.krml kremlin/FStar_Range.krml kremlin/FStar_Reflection_Types.krml kremlin/FStar_Tactics_Types.krml kremlin/FStar_Tactics_Result.krml kremlin/FStar_Tactics_Effect.krml kremlin/FStar_Tactics_Util.krml kremlin/FStar_Reflection_Data.krml kremlin/FStar_Reflection_Const.krml kremlin/FStar_Char.krml kremlin/FStar_Exn.krml kremlin/FStar_Set.krml kremlin/FStar_Monotonic_Witnessed.krml kremlin/FStar_Ghost.krml kremlin/FStar_ErasedLogic.krml kremlin/FStar_PropositionalExtensionality.krml kremlin/FStar_PredicateExtensionality.krml kremlin/FStar_TSet.krml kremlin/FStar_Monotonic_Heap.krml kremlin/FStar_Heap.krml kremlin/FStar_ST.krml kremlin/FStar_All.krml kremlin/FStar_List.krml kremlin/FStar_String.krml kremlin/FStar_Order.krml kremlin/FStar_Reflection_Basic.krml kremlin/FStar_Reflection_Derived.krml kremlin/FStar_Tactics_Builtins.krml kremlin/FStar_Reflection_Formula.krml kremlin/FStar_Reflection_Derived_Lemmas.krml kremlin/FStar_Reflection.krml kremlin/FStar_Tactics_Derived.krml kremlin/FStar_Tactics_Logic.krml kremlin/FStar_Tactics.krml kremlin/FStar_Map.krml kremlin/FStar_Monotonic_HyperHeap.krml kremlin/FStar_Monotonic_HyperStack.krml kremlin/FStar_HyperStack.krml kremlin/FStar_HyperStack_ST.krml kremlin/FStar_Universe.krml kremlin/FStar_GSet.krml kremlin/FStar_ModifiesGen.krml kremlin/FStar_BigOps.krml kremlin/LowStar_Monotonic_Buffer.krml kremlin/LowStar_Buffer.krml kremlin/FStar_UInt8.krml kremlin/LowParse_Bytes.krml kremlin/LowParse_Spec_Base.krml kremlin/LowParse_Spec_Combinators.krml kremlin/LowParse_Spec_FLData.krml kremlin/Spec_Loops.krml kremlin/FStar_UInt64.krml kremlin/LowStar_BufferOps.krml kremlin/C_Loops.krml kremlin/LowParse_Math.krml kremlin/LowParse_Slice.krml kremlin/LowParse_Low_Base.krml kremlin/LowParse_Low_Combinators.krml kremlin/LowParse_Low_FLData.krml kremlin/FStar_Int64.krml kremlin/FStar_Int63.krml kremlin/FStar_Int32.krml kremlin/FStar_Int8.krml kremlin/FStar_UInt63.krml kremlin/FStar_UInt16.krml kremlin/FStar_Int_Cast.krml kremlin/FStar_HyperStack_All.krml kremlin/FStar_Kremlin_Endianness.krml kremlin/LowParse_BigEndian.krml kremlin/LowParse_Spec_Int_Aux.krml kremlin/LowParse_Spec_Int.krml kremlin/LowParse_Spec_BoundedInt.krml kremlin/LowStar_Modifies.krml kremlin/LowStar_ModifiesPat.krml kremlin/LowParse_BigEndianImpl_Base.krml kremlin/LowParse_BigEndianImpl_Low.krml kremlin/LowParse_Low_BoundedInt.krml kremlin/LowParse_Spec_SeqBytes_Base.krml kremlin/LowParse_Spec_DER.krml kremlin/LowParse_Spec_BCVLI.krml kremlin/LowParse_Spec_AllIntegers.krml kremlin/LowParse_Spec_VLData.krml kremlin/LowParse_Low_VLData.krml kremlin/LowParse_Spec_VLGen.krml kremlin/LowParse_Low_VLGen.krml kremlin/LowParse_Spec_Int_Unique.krml kremlin/LowParse_Low_Int_Aux.krml kremlin/LowParse_Low_Int.krml kremlin/LowParse_Low_DER.krml kremlin/LowParse_Low_BCVLI.krml kremlin/LowParse_Spec_List.krml kremlin/LowParse_Low_List.krml kremlin/LowParse_Spec_Array.krml kremlin/LowParse_Spec_VCList.krml kremlin/LowParse_Low_VCList.krml kremlin/LowParse_Spec_IfThenElse.krml kremlin/LowParse_Low_IfThenElse.krml kremlin/LowParse_TacLib.krml kremlin/LowParse_Spec_Enum.krml kremlin/LowParse_Spec_Sum.krml kremlin/LowParse_Low_Enum.krml kremlin/LowParse_Low_Sum.krml kremlin/LowParse_Low_Tac_Sum.krml kremlin/LowParse_Spec_Option.krml kremlin/LowParse_Low_Option.krml kremlin/FStar_Bytes.krml kremlin/LowParse_Bytes32.krml kremlin/LowParse_Spec_Bytes.krml kremlin/LowParse_Low_Bytes.krml kremlin/LowParse_Low_Array.krml kremlin/LowParse_Low.krml kremlin/LowParse_SLow_Base.krml kremlin/LowParse_SLow_Combinators.krml kremlin/LowParse_SLow_FLData.krml kremlin/LowParse_SLow_VLGen.krml kremlin/LowParse_BigEndianImpl_SLow.krml kremlin/LowParse_SLow_BoundedInt.krml kremlin/LowParse_SLow_Int_Aux.krml kremlin/LowParse_SLow_Int.krml kremlin/LowParse_SLow_DER.krml kremlin/LowParse_SLow_BCVLI.krml kremlin/LowParse_SLow_List.krml kremlin/LowParse_SLow_VCList.krml kremlin/LowParse_SLow_IfThenElse.krml kremlin/LowParse_SLow_Option.krml kremlin/LowParse_SLow_Enum.krml kremlin/LowParse_SLow_Sum.krml kremlin/LowParse_SLow_Tac_Enum.krml kremlin/LowParse_SLow_Tac_Sum.krml kremlin/LowParse_SLow_VLData.krml kremlin/LowParse_SLow_Bytes.krml kremlin/LowParse_SLow_Array.krml kremlin/LowParse_Spec_Tac_Combinators.krml kremlin/LowParse_SLow.krml kremlin/Tag2.krml kremlin/T15_body.krml kremlin/T3.krml kremlin/T5.krml kremlin/T9_b.krml kremlin/Amount.krml kremlin/Txout_scriptPubKey.krml kremlin/Txout.krml kremlin/Transaction_outputs.krml kremlin/Txin_scriptSig.krml kremlin/Sha256.krml kremlin/Txin.krml kremlin/Transaction_inputs.krml kremlin/Transaction.krml kremlin/Block_tx.krml kremlin/Block.krml kremlin/T25_bpayload.krml kremlin/FStar_Int128.krml kremlin/FStar_Int31.krml kremlin/FStar_UInt128.krml kremlin/FStar_UInt31.krml kremlin/FStar_Integers.krml kremlin/FStar_Printf.krml kremlin/Tagle.krml kremlin/T4.krml kremlin/T6le.krml kremlin/T24_y.krml kremlin/T24.krml kremlin/T25_payload.krml kremlin/T25.krml kremlin/T14_x.krml kremlin/T13_x.krml kremlin/T13.krml kremlin/T18_x_b.krml kremlin/T20.krml kremlin/T21.krml kremlin/C_Endianness.krml kremlin/C.krml kremlin/C_String.krml kremlin/T26.krml kremlin/Tag.krml kremlin/T16_x.krml kremlin/T16.krml kremlin/LowStar_ImmutableBuffer.krml kremlin/FStar_HyperStack_IO.krml kremlin/LowParse_TestLib_Low.krml kremlin/T18_x_a.krml kremlin/T33.krml kremlin/T19.krml kremlin/T1.krml kremlin/T17_x_b.krml kremlin/T22_body_b.krml kremlin/T12_z.krml kremlin/T12.krml kremlin/T2.krml kremlin/T7.krml kremlin/T8_z.krml kremlin/T27.krml kremlin/T14.krml kremlin/T32.krml kremlin/T29.krml kremlin/T36.krml kremlin/T10.krml kremlin/T17_x_a.krml kremlin/T17.krml kremlin/T15.krml kremlin/T35.krml kremlin/T22_body_a.krml kremlin/FStar_Float.krml kremlin/FStar_IO.krml kremlin/T18.krml kremlin/T23.krml kremlin/T9.krml kremlin/T8.krml kremlin/T28.krml kremlin/T6.krml kremlin/Test.krml kremlin/T30.krml kremlin/T11_z.krml kremlin/T34.krml kremlin/T11.krml kremlin/T31.krml kremlin/T22.krml -o test.exe
  F* version: 74c6d2a5
  KreMLin version: 1bd260eb
 */

#include "Test.h"

void discard(bool uu____10)
{
  
}

void bprint(Prims_string s)
{
  discard(FStar_IO_debug_print_string(Prims_strcat(s, "\n")));
}

typedef struct
K___FStar_Pervasives_Native_option__K___T7_t7_uint32_t_FStar_Pervasives_Native_option__K___T7_t7_uint32_t_s
{
  FStar_Pervasives_Native_option__K___T7_t7_uint32_t fst;
  FStar_Pervasives_Native_option__K___T7_t7_uint32_t snd;
}
K___FStar_Pervasives_Native_option__K___T7_t7_uint32_t_FStar_Pervasives_Native_option__K___T7_t7_uint32_t;

bool
__eq__Prims_list__FStar_Bytes_bytes(
  Prims_list__FStar_Bytes_bytes *y,
  Prims_list__FStar_Bytes_bytes *x
)
{
  if (x->tag == Prims_Nil)
    if (y->tag == Prims_Nil)
      return true;
    else
      return false;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *x_tl = x->tl;
    FStar_Bytes_bytes x_hd = x->hd;
    if (y->tag == Prims_Cons)
    {
      Prims_list__FStar_Bytes_bytes *y_tl = y->tl;
      FStar_Bytes_bytes y_hd = y->hd;
      return
        true
        && __eq__FStar_Bytes_bytes(y_hd, x_hd)
        && __eq__Prims_list__FStar_Bytes_bytes(y_tl, x_tl);
    }
    else
      return false;
  }
  else
    return false;
}

bool __eq__T7_t7(T7_t7 y, T7_t7 x)
{
  if (x.tag == T7_Body_x)
  {
    FStar_Bytes_bytes x__0 = x.case_Body_x;
    if (y.tag == T7_Body_x)
    {
      FStar_Bytes_bytes y__0 = y.case_Body_x;
      return true && __eq__FStar_Bytes_bytes(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == T7_Body_y)
  {
    Prims_list__FStar_Bytes_bytes *x__0 = x.case_Body_y;
    if (y.tag == T7_Body_y)
    {
      Prims_list__FStar_Bytes_bytes *y__0 = y.case_Body_y;
      return true && __eq__Prims_list__FStar_Bytes_bytes(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == T7_Body_w)
    if (y.tag == T7_Body_w)
      return true && true;
    else
      return false;
  else if (x.tag == T7_Body_v)
  {
    Prims_list__FStar_Bytes_bytes *x__0 = x.case_Body_v;
    if (y.tag == T7_Body_v)
    {
      Prims_list__FStar_Bytes_bytes *y__0 = y.case_Body_v;
      return true && __eq__Prims_list__FStar_Bytes_bytes(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == T7_Body_t)
  {
    Prims_list__FStar_Bytes_bytes *x__0 = x.case_Body_t;
    if (y.tag == T7_Body_t)
    {
      Prims_list__FStar_Bytes_bytes *y__0 = y.case_Body_t;
      return true && __eq__Prims_list__FStar_Bytes_bytes(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == T7_Body_z)
  {
    Prims_list__FStar_Bytes_bytes *x__0 = x.case_Body_z;
    if (y.tag == T7_Body_z)
    {
      Prims_list__FStar_Bytes_bytes *y__0 = y.case_Body_z;
      return true && __eq__Prims_list__FStar_Bytes_bytes(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == T7_Body_Unknown_tag2)
  {
    Prims_list__FStar_Bytes_bytes *x_x = x.case_Body_Unknown_tag2.x;
    uint8_t x_v = x.case_Body_Unknown_tag2.v;
    if (y.tag == T7_Body_Unknown_tag2)
    {
      Prims_list__FStar_Bytes_bytes *y_x = y.case_Body_Unknown_tag2.x;
      uint8_t y_v = y.case_Body_Unknown_tag2.v;
      return true && y_v == x_v && __eq__Prims_list__FStar_Bytes_bytes(y_x, x_x);
    }
    else
      return false;
  }
  else
    return false;
}

bool test_open_enum()
{
  C_String_print("Testing open enum parser.\n");
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf0[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf1[0U]
  =
    (
      (Prims_list__FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = FStar_Bytes_twobytes((
            (K___uint8_t_uint8_t){ .fst = (uint8_t)255U, .snd = (uint8_t)0U }
          )),
        .tl = buf0
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf2 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf2[0U]
  =
    (
      (Prims_list__FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)2U, .snd = (uint8_t)6U })),
        .tl = buf1
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf3 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf3[0U]
  =
    (
      (Prims_list__FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)3U, .snd = (uint8_t)5U })),
        .tl = buf2
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf4 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf4[0U]
  =
    (
      (Prims_list__FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0U, .snd = (uint8_t)1U })),
        .tl = buf3
      }
    );
  T7_t7 x = { .tag = T7_Body_y, { .case_Body_y = buf4 } };
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf5 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf5[0U]
  =
    (
      (Prims_list__FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = FStar_Bytes_create((uint32_t)12U, (uint8_t)9U),
        .tl = buf
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *tmp = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  tmp[0U]
  =
    (
      (Prims_list__FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = FStar_Bytes_create((uint32_t)10U, (uint8_t)7U),
        .tl = buf5
      }
    );
  T7_t7
  y =
    { .tag = T7_Body_Unknown_tag2, { .case_Body_Unknown_tag2 = { .v = (uint8_t)33U, .x = tmp } } };
  FStar_Bytes_bytes xb = T7_t7_serializer32(x);
  FStar_Bytes_bytes yb = T7_t7_serializer32(y);
  bprint(Prims_strcat("Serialized (case Y): ", FStar_Bytes_hex_of_bytes(xb)));
  bprint(Prims_strcat("Serialized (default case): ", FStar_Bytes_hex_of_bytes(yb)));
  K___FStar_Pervasives_Native_option__K___T7_t7_uint32_t_FStar_Pervasives_Native_option__K___T7_t7_uint32_t
  scrut = { .fst = T7_t7_parser32(xb), .snd = T7_t7_parser32(yb) };
  if
  (
    scrut.fst.tag
    == FStar_Pervasives_Native_Some
    && scrut.snd.tag == FStar_Pervasives_Native_Some
  )
  {
    uint32_t r_ = scrut.snd.v.snd;
    T7_t7 y_ = scrut.snd.v.fst;
    uint32_t r = scrut.fst.v.snd;
    T7_t7 x_ = scrut.fst.v.fst;
    if
    (
      __eq__T7_t7(x,
        x_)
      && r == FStar_Bytes_len(xb)
      && __eq__T7_t7(y, y_)
      && r_ == FStar_Bytes_len(yb)
    )
    {
      C_String_print("Roundtrip OK.\n\n");
      return true;
    }
    else
    {
      C_String_print("Roundtrip failed.\n\n");
      return false;
    }
  }
  else
  {
    C_String_print("failed.\n");
    return false;
  }
}

static bool __eq__T6_t6(T6_t6 y, T6_t6 x)
{
  if (x.tag == T6_Body_a)
  {
    FStar_Bytes_bytes x__0 = x.case_Body_a;
    if (y.tag == T6_Body_a)
    {
      FStar_Bytes_bytes y__0 = y.case_Body_a;
      return true && __eq__FStar_Bytes_bytes(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == T6_Body_b)
  {
    Prims_list__FStar_Bytes_bytes *x__0 = x.case_Body_b;
    if (y.tag == T6_Body_b)
    {
      Prims_list__FStar_Bytes_bytes *y__0 = y.case_Body_b;
      return true && __eq__Prims_list__FStar_Bytes_bytes(y__0, x__0);
    }
    else
      return false;
  }
  else
    return false;
}

bool test_closed_enum()
{
  C_String_print("Testing closed enum parser.\n");
  T6_t6
  x =
    {
      .tag = T6_Body_a,
      {
        .case_Body_a = FStar_Bytes_twobytes((
            (K___uint8_t_uint8_t){ .fst = (uint8_t)127U, .snd = (uint8_t)63U }
          ))
      }
    };
  FStar_Bytes_bytes xb = T6_t6_serializer32(x);
  bprint(Prims_strcat("Serialized: ", FStar_Bytes_hex_of_bytes(xb)));
  FStar_Pervasives_Native_option__K___T6_t6_uint32_t scrut = T6_t6_parser32(xb);
  if (scrut.tag == FStar_Pervasives_Native_None)
  {
    C_String_print("failed.\n");
    return false;
  }
  else if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t r = scrut.v.snd;
    T6_t6 x_ = scrut.v.fst;
    if (__eq__T6_t6(x, x_) && r == FStar_Bytes_len(xb))
    {
      C_String_print("Roundtrip OK.\n\n");
      return true;
    }
    else
    {
      C_String_print("Roundtrip failed.\n\n");
      return false;
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool test_bitcoin()
{
  FStar_Bytes_bytes
  block =
    FStar_Bytes_bytes_of_hex("030000009185dbc5e60723af6b4cdcdb5ceea505bc1cf7fe85097d02000000000000000001fef45c2701088577dffd37927b20da129acce6303f2ba3116ce032b4f8a5018de2dd55c4431418cb638acc0201000000010000000000000000000000000000000000000000000000000000000000000000ffffffff5703a7ab052f4249503130302f048fe2dd550850030f240c3900003c5b4254434368696e612e636f6d5d20e5b9b8e7a68fe4b88de59ca8e5be97e588b0e5a49a20e8808ce59ca8e8aea1e8be83e5b0912d2de4b99de6809d000000000100f90295000000001976a9142c30a6aaac6d96687291475d7d52f4b469f665a688ac000000000100000001f71c1cd429d1800080147ef63b2aa7440273d1ecdb2b0a1da01aded965e2ca8e000000006b483045022100de5bdb5a365fb16cc4057f1b1c1d9aabf130e85a9da6c184f186d0d0fbe7afd7022024321c4a53c4f5017153a666e10c65e4d790eb100fb4d66eaac8f9417699351c012102163e80de410646145142636833d8a92de4bb5c99e49bd52be5346fb1030628d4ffffffff02f05e3102000000001976a9145ca26d65ee83f441ef98b624763a305d50eb36cf88aca0860100000000001976a914838eb1034b719f9c47ab853aee63d505e4176a8388ac00000000");
  KRML_CHECK_SIZE(sizeof (uint8_t), FStar_Bytes_len(block));
  uint8_t lb[FStar_Bytes_len(block)];
  memset(lb, 0U, FStar_Bytes_len(block) * sizeof lb[0U]);
  FStar_Bytes_store_bytes(block, lb);
  uint8_t *lb0 = lb;
  LowParse_Slice_slice slice1 = { .base = lb0, .len = FStar_Bytes_len(block) };
  if (Block_block_validator(slice1, (uint32_t)0U) > LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH)
  {
    C_String_print("Validator failed on Bitcoin block!\n");
    return false;
  }
  else
  {
    uint32_t pos_random = Block_accessor_block_prev_block(slice1, (uint32_t)0U);
    uint8_t *p_random = lb0 + pos_random;
    bprint(Prims_strcat(" The previous block hash is: ",
        FStar_Bytes_hex_of_bytes(FStar_Bytes_of_buffer((uint32_t)32U, p_random))));
    return true;
  }
}

exit_code test_zeroarg()
{
  bool b1 = test_closed_enum();
  bool b2;
  if (b1)
    b2 = test_open_enum();
  else
    b2 = false;
  bool b3;
  if (b2)
    b3 = test_bitcoin();
  else
    b3 = false;
  if (b3)
    return EXIT_SUCCESS;
  else
    return EXIT_FAILURE;
}

void test_bitcoin_file(C_String_t filename)
{
  LowParse_Slice_slice slice1 = LowParse_TestLib_Low_load_file_buffer_c(filename);
  if (slice1.len > LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH)
    C_String_print("Input data is too large\n");
  else
  {
    uint32_t consumed = Block_block_validator(slice1, (uint32_t)0U);
    if (consumed > LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH)
      C_String_print("Validation failed\n");
    else if (consumed == slice1.len)
      C_String_print("Validation succeeded, everything consumed\n");
    else
      C_String_print("Validation succeeded, but some data left over\n");
  }
}

exit_code main(int32_t argc, C_String_t *argv)
{
  kremlinit_globals();
  if (argc < (int32_t)2)
    return test_zeroarg();
  else
  {
    C_String_t filename = argv[1U];
    C_String_print(filename);
    C_String_print("\n");
    test_bitcoin_file(filename);
    return EXIT_SUCCESS;
  }
}

