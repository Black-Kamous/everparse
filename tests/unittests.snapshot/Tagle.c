/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -I ../../src/lowparse -skip-compilation -tmpdir ../unittests.snapshot -bundle LowParse.\* -drop FStar.Tactics.\* -drop FStar.Reflection.\* T10.fst T11.fst T11_z.fst T12.fst T12_z.fst T13.fst T13_x.fst T14.fst T14_x.fst T15_body.fst T15.fst T16.fst T16_x.fst T17.fst T17_x_a.fst T17_x_b.fst T18.fst T18_x_a.fst T18_x_b.fst T19.fst T1.fst T20.fst T21.fst T22_body_a.fst T22_body_b.fst T22.fst T23.fst T24.fst T24_y.fst T25_bpayload.fst T25.fst T25_payload.fst T26.fst T27.fst T28.fst T29.fst T2.fst T30.fst T31.fst T32.fst T33.fst T34.fst T35.fst T36.fst T3.fst T4.fst T5.fst T6.fst T6le.fst T7.fst T8.fst T8_z.fst T9_b.fst T9.fst Tag2.fst Tag.fst Tagle.fst -warn-error +9
  F* version: 74c6d2a5
  KreMLin version: 1bd260eb
 */

#include "Tagle.h"

bool Tagle_uu___is_A(Tagle_tagle projectee)
{
  switch (projectee)
  {
    case Tagle_A:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Tagle_uu___is_B(Tagle_tagle projectee)
{
  switch (projectee)
  {
    case Tagle_B:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

Prims_string Tagle_string_of_tagle(Tagle_tagle uu___0_8504)
{
  switch (uu___0_8504)
  {
    case Tagle_A:
      {
        return "a";
      }
    case Tagle_B:
      {
        return "b";
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t Tagle_tagle_validator(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t res;
  if (input.len - pos < (uint32_t)1U)
    res = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    res = pos + (uint32_t)1U;
  if (res > LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH)
    return res;
  else
  {
    uint8_t va = LowParse_Low_Int_read_u8(input, pos);
    bool ite;
    if (va == (uint8_t)0U)
      ite = true;
    else if (va == (uint8_t)1U)
      ite = true;
    else
      ite = false;
    if (ite)
      return res;
    else
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
  }
}

uint32_t Tagle_tagle_jumper(LowParse_Slice_slice input, uint32_t pos)
{
  return pos + (uint32_t)1U;
}

Tagle_tagle Tagle_tagle_reader(LowParse_Slice_slice input, uint32_t pos)
{
  uint8_t res = LowParse_Low_Int_read_u8(input, pos);
  if (res == (uint8_t)0U)
    return Tagle_A;
  else if (res == (uint8_t)1U)
    return Tagle_B;
  else
    return Tagle_A;
}

static bool __eq__Tagle_tagle(Tagle_tagle y, Tagle_tagle x)
{
  switch (x)
  {
    case Tagle_A:
      {
        switch (y)
        {
          case Tagle_A:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Tagle_B:
      {
        switch (y)
        {
          case Tagle_B:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

uint32_t Tagle_tagle_writer(Tagle_tagle x, LowParse_Slice_slice input, uint32_t pos)
{
  uint8_t ite;
  if (__eq__Tagle_tagle(Tagle_A, x))
    ite = (uint8_t)0U;
  else
    ite = (uint8_t)1U;
  uint32_t res = LowParse_Low_Int_write_u8(ite, input, pos);
  uint32_t pos_ = res;
  uint32_t pos_0 = pos_;
  return pos_0;
}

