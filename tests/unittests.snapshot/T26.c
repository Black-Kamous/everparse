/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -I ../../src/lowparse -skip-compilation -tmpdir ../unittests.snapshot -bundle LowParse.\* -drop FStar.Tactics.\* -drop FStar.Reflection.\* T10.fst T11.fst T11_z.fst T12.fst T12_z.fst T13.fst T13_x.fst T14.fst T14_x.fst T15_body.fst T15.fst T16.fst T16_x.fst T17.fst T17_x_a.fst T17_x_b.fst T18.fst T18_x_a.fst T18_x_b.fst T19.fst T1.fst T20.fst T21.fst T22_body_a.fst T22_body_b.fst T22.fst T23.fst T24.fst T24_y.fst T25_bpayload.fst T25.fst T25_payload.fst T26.fst T27.fst T28.fst T29.fst T2.fst T30.fst T31.fst T32.fst T33.fst T34.fst T35.fst T36.fst T3.fst T4.fst T5.fst T6.fst T6le.fst T7.fst T8.fst T8_z.fst T9_b.fst T9.fst Tag2.fst Tag.fst Tagle.fst -warn-error +9
  F* version: 74c6d2a5
  KreMLin version: 1bd260eb
 */

#include "T26.h"

uint32_t T26_t26_validator(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t v10;
  if (input.len - pos < (uint32_t)1U)
    v10 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    v10 = pos + (uint32_t)1U;
  uint32_t n1;
  if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < v10)
    n1 = v10;
  else
  {
    uint8_t x = LowParse_Low_Int_read_u8(input, pos);
    uint8_t len1;
    if (x < (uint8_t)129U || x == (uint8_t)255U)
      len1 = (uint8_t)0U;
    else
      len1 = x - (uint8_t)128U;
    uint8_t tg1;
    if ((uint32_t)0U < (uint32_t)128U)
      tg1 = (uint8_t)(uint32_t)0U;
    else
    {
      uint8_t len_len;
      if ((uint32_t)0U < (uint32_t)256U)
        len_len = (uint8_t)1U;
      else if ((uint32_t)0U < (uint32_t)65536U)
        len_len = (uint8_t)2U;
      else if ((uint32_t)0U < (uint32_t)16777216U)
        len_len = (uint8_t)3U;
      else
        len_len = (uint8_t)4U;
      tg1 = (uint8_t)128U + len_len;
    }
    uint8_t l1;
    if (tg1 < (uint8_t)129U || tg1 == (uint8_t)255U)
      l1 = (uint8_t)0U;
    else
      l1 = tg1 - (uint8_t)128U;
    uint8_t tg2;
    if ((uint32_t)255U < (uint32_t)128U)
      tg2 = (uint8_t)(uint32_t)255U;
    else
    {
      uint8_t len_len;
      if ((uint32_t)255U < (uint32_t)256U)
        len_len = (uint8_t)1U;
      else if ((uint32_t)255U < (uint32_t)65536U)
        len_len = (uint8_t)2U;
      else if ((uint32_t)255U < (uint32_t)16777216U)
        len_len = (uint8_t)3U;
      else
        len_len = (uint8_t)4U;
      tg2 = (uint8_t)128U + len_len;
    }
    uint8_t l2;
    if (tg2 < (uint8_t)129U || tg2 == (uint8_t)255U)
      l2 = (uint8_t)0U;
    else
      l2 = tg2 - (uint8_t)128U;
    if (len1 < l1 || l2 < len1)
      n1 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
    else
    {
      uint32_t v20;
      if (x < (uint8_t)128U)
        v20 = v10;
      else if (x == (uint8_t)128U || x == (uint8_t)255U)
        v20 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
      else if (x == (uint8_t)129U)
      {
        uint32_t v2;
        if (input.len - v10 < (uint32_t)1U)
          v2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
        else
          v2 = v10 + (uint32_t)1U;
        if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < v2)
          v20 = v2;
        else
        {
          uint8_t z = LowParse_Low_Int_read_u8(input, v10);
          if (z < (uint8_t)128U)
            v20 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
          else
            v20 = v2;
        }
      }
      else
      {
        uint8_t len2 = x - (uint8_t)128U;
        if (len2 == (uint8_t)2U)
        {
          uint32_t v2;
          if (input.len - v10 < (uint32_t)2U)
            v2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
          else
            v2 = v10 + (uint32_t)2U;
          if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < v2)
            v20 = v2;
          else
          {
            uint32_t y = LowParse_Low_BoundedInt_read_bounded_integer_2(input, v10);
            if (y < (uint32_t)256U)
              v20 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
            else
              v20 = v2;
          }
        }
        else if (len2 == (uint8_t)3U)
        {
          uint32_t v2;
          if (input.len - v10 < (uint32_t)3U)
            v2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
          else
            v2 = v10 + (uint32_t)3U;
          if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < v2)
            v20 = v2;
          else
          {
            uint32_t y = LowParse_Low_BoundedInt_read_bounded_integer_3(input, v10);
            if (y < (uint32_t)65536U)
              v20 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
            else
              v20 = v2;
          }
        }
        else
        {
          uint32_t v2;
          if (input.len - v10 < (uint32_t)4U)
            v2 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
          else
            v2 = v10 + (uint32_t)4U;
          if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < v2)
            v20 = v2;
          else
          {
            uint32_t y = LowParse_Low_BoundedInt_read_bounded_integer_4(input, v10);
            if (y < (uint32_t)16777216U)
              v20 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
            else
              v20 = v2;
          }
        }
      }
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < v20)
        n1 = v20;
      else
      {
        uint32_t y;
        if (x < (uint8_t)128U)
          y = (uint32_t)x;
        else if (x == (uint8_t)129U)
        {
          uint8_t z = LowParse_Low_Int_read_u8(input, v10);
          y = (uint32_t)z;
        }
        else
        {
          uint8_t len2 = x - (uint8_t)128U;
          if (len2 == (uint8_t)2U)
          {
            uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_2(input, v10);
            y = res;
          }
          else if (len2 == (uint8_t)3U)
          {
            uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_3(input, v10);
            y = res;
          }
          else
          {
            uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_4(input, v10);
            y = res;
          }
        }
        if (y < (uint32_t)0U || (uint32_t)255U < y)
          n1 = LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          n1 = v20;
      }
    }
  }
  if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < n1)
    return n1;
  else
  {
    uint32_t v1 = pos + (uint32_t)1U;
    uint8_t x = LowParse_Low_Int_read_u8(input, pos);
    uint8_t len1;
    if (x < (uint8_t)129U || x == (uint8_t)255U)
      len1 = (uint8_t)0U;
    else
      len1 = x - (uint8_t)128U;
    uint32_t y;
    if (x < (uint8_t)128U)
      y = (uint32_t)x;
    else if (x == (uint8_t)129U)
    {
      uint8_t z = LowParse_Low_Int_read_u8(input, v1);
      y = (uint32_t)z;
    }
    else
    {
      uint8_t len2 = x - (uint8_t)128U;
      if (len2 == (uint8_t)2U)
      {
        uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_2(input, v1);
        y = res;
      }
      else if (len2 == (uint8_t)3U)
      {
        uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_3(input, v1);
        y = res;
      }
      else
      {
        uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_4(input, v1);
        y = res;
      }
    }
    uint32_t len10 = y;
    if (input.len - n1 < len10)
      return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA;
    else
    {
      uint32_t
      pos_ =
        T25_t25_validator(((LowParse_Slice_slice){ .base = input.base, .len = n1 + len10 }),
          n1);
      if (LOWPARSE_LOW_BASE_VALIDATOR_MAX_LENGTH < pos_)
        if (pos_ == LOWPARSE_LOW_BASE_VALIDATOR_ERROR_NOT_ENOUGH_DATA)
          return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
        else
          return pos_;
      else if (pos_ - n1 != len10)
        return LOWPARSE_LOW_BASE_VALIDATOR_ERROR_GENERIC;
      else
        return pos_;
    }
  }
}

uint32_t T26_t26_jumper(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t v10 = pos + (uint32_t)1U;
  uint8_t x0 = LowParse_Low_Int_read_u8(input, pos);
  uint8_t len10;
  if (x0 < (uint8_t)129U || x0 == (uint8_t)255U)
    len10 = (uint8_t)0U;
  else
    len10 = x0 - (uint8_t)128U;
  uint32_t n1;
  if (x0 < (uint8_t)128U)
    n1 = v10;
  else
    n1 = v10 + (uint32_t)(x0 - (uint8_t)128U);
  uint32_t v1 = pos + (uint32_t)1U;
  uint8_t x = LowParse_Low_Int_read_u8(input, pos);
  uint8_t len1;
  if (x < (uint8_t)129U || x == (uint8_t)255U)
    len1 = (uint8_t)0U;
  else
    len1 = x - (uint8_t)128U;
  uint32_t y;
  if (x < (uint8_t)128U)
    y = (uint32_t)x;
  else if (x == (uint8_t)129U)
  {
    uint8_t z = LowParse_Low_Int_read_u8(input, v1);
    y = (uint32_t)z;
  }
  else
  {
    uint8_t len2 = x - (uint8_t)128U;
    if (len2 == (uint8_t)2U)
    {
      uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_2(input, v1);
      y = res;
    }
    else if (len2 == (uint8_t)3U)
    {
      uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_3(input, v1);
      y = res;
    }
    else
    {
      uint32_t res = LowParse_Low_BoundedInt_read_bounded_integer_4(input, v1);
      y = res;
    }
  }
  uint32_t len11 = y;
  return n1 + len11;
}

uint32_t T26_t26_accessor(LowParse_Slice_slice input, uint32_t pos)
{
  uint32_t pos2 = pos;
  uint32_t v1 = pos2 + (uint32_t)1U;
  uint8_t x = LowParse_Low_Int_read_u8(input, pos2);
  uint8_t len1;
  if (x < (uint8_t)129U || x == (uint8_t)255U)
    len1 = (uint8_t)0U;
  else
    len1 = x - (uint8_t)128U;
  if (x < (uint8_t)128U)
    return v1;
  else
    return v1 + (uint32_t)(x - (uint8_t)128U);
}

