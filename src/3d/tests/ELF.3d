#define MAX_UINT32 0xffffffff

typedef UINT8 UCHAR;

typedef struct _ZeroByte
{
    UINT8 zero { zero == 0 };
} ZeroByte;

// Address type is either UINT64 or UINT32 depending on the architecture
// For now, the spec supports only 64 bit arch, later we could parameterize
//   the Address type

// The same goes for the OFFSET type

typedef UINT64 ADDRESS;

typedef UINT64 OFFSET;

#define ELFMAG0    0x7f
#define ELFMAG1    0x45  //'E'
#define ELFMAG2    0x4c  //'L'
#define ELFMAG3    0x46  //'F'

UINT8 enum ELFCLASS
{
  ELFCLASSNONE = 0,
  ELFCLASS32,
  ELFCLASS64
}
  
UINT8 enum ELFDATA
{
  ELFDATANONE = 0,
  ELFDATA2LSB,
  ELFDATA2MSB
}

UINT8 enum ELFOSABI
{
  ELFOSABI_NONE = 0,
  ELFOSABI_SYSV,
  ELFOSABI_HPUX,
  ELFOSABI_NETBSD,
  ELFOSABI_LINUX,
  ELFOSABI_SOLARIS,
  ELFOSABI_IRIX,
  ELFOSABI_FREEBSD,
  ELFOSABI_TRU64,
  ELFOSABI_ARM,
  ELFOSABI_STANDALONE,
}

#define E_IDENT_PADDING_SIZE    7

typedef struct _E_IDENT
{
  //The first four bytes are 0x7f followed by 'E', 'L', and 'F'
  
  UCHAR    ZERO    { ZERO == ELFMAG0 };
  UCHAR    ONE     { ONE == ELFMAG1 };
  UCHAR    TWO     { TWO == ELFMAG2 };
  UCHAR    THREE   { THREE == ELFMAG3 };

  ELFCLASS FOUR   //architecture for this binary
                  //TODO: should we say that it can't be ELFCLASSNONE to reject such binaries?
    { FOUR == ELFCLASS64 };  //TODO: 64 only for now

  
  ELFDATA  FIVE;  //TODO: Ditto, reject ELFDATANONE?

  UCHAR    SIX    { SIX == 1 };  //version is always set to 1

  ELFOSABI SEVEN;

  ZeroByte EIGHT;  //ABI version, always set to 0
                   //TODO: should it be a soft constraint?

  ZeroByte NINE_FIFTEEN[E_IDENT_PADDING_SIZE];  //padding
} E_IDENT;


UINT16 enum ELF_TYPE
{
  ET_NONE = 0,
  ET_REL,
  ET_EXEC,
  ET_DYN,
  ET_CORE
}

typedef struct _PROGRAM_HEADER_TABLE_ENTRY (OFFSET ElfFileSize)
{
  //
  // TODO: It looks like this type has some defined values and then
  //      some open ones for processor-specific usage, should we constrain it?        

  UINT32    P_TYPE;

  //
  // TODO: it is a bitmask of flags
  //
  UINT32    P_FLAGS  { P_FLAGS <= 7 };

  OFFSET    P_OFFSET;

  ADDRESS   P_VADDR;

  //
  // TODO: Under BSD this must be zero?
  //
  ADDRESS   P_PADDR;

  //
  // Check that the pointed to segment lies within the file
  //

  UINT64    P_FILESZ  { P_FILESZ < ElfFileSize &&
                        P_OFFSET <= ElfFileSize - P_FILESZ };
  UINT64    P_MEMSZ;

  //
  // TODO: There is another constraints that it should be a power of 2
  //       This failed on Linux: { P_ALIGN == 0 || P_VADDR == P_OFFSET % P_ALIGN }

  UINT64    P_ALIGN;
} PROGRAM_HEADER_TABLE_ENTRY;

casetype _PROGRAM_HEADER_TABLE_OPT (Bool   HasProgramHeaderTable,
                                    UINT16 PhNum,
				    OFFSET ElfFileSize)
{
  switch (HasProgramHeaderTable)
  {
    case false:
      unit    Empty;
    case true:
      PROGRAM_HEADER_TABLE_ENTRY(ElfFileSize)    Tbl[:byte-size sizeof (PROGRAM_HEADER_TABLE_ENTRY) * PhNum]
   }
} PROGRAM_HEADER_TABLE_OPT;


//When a section is of type SH_NOBITS, its size is not really the size that it occupies

#define SH_NOBITS        8


typedef struct _SECTION_HEADER_TABLE_ENTRY (UINT16 ShNum,
					    OFFSET ElfFileSize)
{
  //
  // TODO: Offset into the section header string table,
  //       whose section index is in the ELF Header
  
  UINT32        SH_NAME;

  //
  // TODO: Similar to type in the program header table entry,
  //       is this an enum / any restrictions on its value?

  UINT32        SH_TYPE;

  // TODO: Any constraints on this?

  UINT64        SH_FLAGS;

  ADDRESS       SH_ADDR;

  OFFSET        SH_OFFSET;
  UINT64        SH_SIZE        { SH_TYPE == SH_NOBITS || (SH_SIZE <= ElfFileSize && SH_OFFSET <= ElfFileSize - SH_SIZE) };

  // It is another index in the Section Header Table

  UINT32        SH_LINK        { SH_LINK < ShNum };

  UINT32        SH_INFO;

  UINT64        SH_ADDRALIGN;
  UINT64        SH_ENTSIZE;
} SECTION_HEADER_TABLE_ENTRY;


typedef struct _SECTION_HEADER_TABLE (OFFSET PhTableEnd,
                                      UINT64 ShOff,  //TODO: Writing OFFSET here fails
                                      UINT16 ShNum,
				      OFFSET ElfFileSize)
where (PhTableEnd <= ShOff && ShOff - PhTableEnd <= MAX_UINT32)
{
  UINT8        PHTABLE_SHTABLE_GAP[(UINT32) (ShOff - PhTableEnd)];

  SECTION_HEADER_TABLE_ENTRY(ShNum, ElfFileSize)    SHTABLE[:byte-size sizeof (SECTION_HEADER_TABLE_ENTRY) * ShNum];

  unit        EndOfFile
  {:on-success var x = field_pos; return (x == ElfFileSize); };  
} SECTION_HEADER_TABLE;


typedef struct _NO_SECTION_HEADER_TABLE (OFFSET PhTableEnd,
					 UINT64 ElfFileSize)
where (PhTableEnd <= ElfFileSize && ElfFileSize - PhTableEnd <= MAX_UINT32)
{
  UINT8        Rest[:byte-size (UINT32) (ElfFileSize - PhTableEnd)];
} NO_SECTION_HEADER_TABLE;


casetype _SECTION_HEADER_TABLE_OPT (Bool   HasSectionHeaderTable,
                                    OFFSET PhTableEnd,
                                    OFFSET ShOff,
                                    UINT16 ShNum,
				    OFFSET ElfFileSize)
{
  switch (HasSectionHeaderTable)
  {
    case false:
      NO_SECTION_HEADER_TABLE(PhTableEnd, ElfFileSize)                   NoTbl;      
    case true:
      SECTION_HEADER_TABLE(PhTableEnd, ShOff, ShNum, ElfFileSize)        Tbl;
  }
} SECTION_HEADER_TABLE_OPT;

// The largest allowed value of the E_PHNUM field in the ELF Header

#define PN_XNUM        0xffff

// The largest allowed value of the E_SHNUM field in the ELF Haeder

#define SHN_LORESERVE  0xff00

// Value of E_SHSTRNDX when the ELF file has no Section Header table

#define SHN_UNDEF      0


entrypoint
typedef struct _ELF (UINT64 ElfFileSize)  //TODO: using OFFSET fails
{
  // ELF HEADER BEGIN

  E_IDENT          IDENT;
  ELF_TYPE         E_TYPE       { E_TYPE != ET_NONE };

  //
  // We can restrict the values of E_MACHINE by making its type an enum, for example
  // The elf man page lists some possible values, but that list does not seem to be exhaustive
  //
  
  UINT16           E_MACHINE;
  UINT32           E_VERSION    { E_VERSION == 1 };
  ADDRESS          E_ENTRY;

  OFFSET           E_PHOFF;  // See E_PHNUM below

  OFFSET           E_SHOFF;
  UINT32           E_FLAGS;

  //
  // The sizes of the ELF Header, and each Program Header entry and Section Header entry
  // are fixed statically, so we will restrict these values in the ELF header
  //
  
  UINT16           E_EHSIZE     { E_EHSIZE == sizeof (this) };

  UINT16           E_PHENTSIZE;

  //
  // When the number of entries is more than PN_XNUM,
  // the ELF spec describes an alternate scheme,
  // our 3d spec does not implement that alternate scheme yet
  //
  // Similarly for E_SHNUM
  //

  //
  // When the ELF file has no Program Header table,
  // E_PHNUM and E_PHOFF are 0
  // Else, is it always the case that the table starts immediately after the ELF Header?
  //

  // Is E_PHENTSIZE fixed?
  
  UINT16           E_PHNUM
    { (E_PHNUM == 0 && E_PHOFF == 0) ||
      (E_PHNUM < PN_XNUM &&
       sizeof (this) == E_PHOFF &&
       E_PHENTSIZE == sizeof (PROGRAM_HEADER_TABLE_ENTRY)) };
  
  UINT16           E_SHENTSIZE;


  // Is E_SHENTSIZE fixed?
  
  UINT16           E_SHNUM
    { (E_SHNUM == 0 && E_SHOFF == 0) ||
      (E_SHNUM < SHN_LORESERVE &&
       E_SHENTSIZE == sizeof (SECTION_HEADER_TABLE_ENTRY)) };

  //
  // Either no Section Header table or a valid index into that table
  //
  
  UINT16           E_SHSTRNDX
    { (E_SHNUM == 0 && E_SHSTRNDX == SHN_UNDEF) ||
      (0 < E_SHNUM  && E_SHSTRNDX < E_SHNUM) };
	
  // ELF HEADER END


  // Program Header Table

  PROGRAM_HEADER_TABLE_OPT (E_PHOFF != 0,
                            E_PHNUM,
			    ElfFileSize)            PH_TABLE;

  // Section Header Table

  SECTION_HEADER_TABLE_OPT (E_SHOFF != 0,
                            (E_PHNUM == 0) ? E_EHSIZE : E_PHOFF + (sizeof (PROGRAM_HEADER_TABLE_ENTRY) * E_PHNUM),
                            E_SHOFF,
                            E_SHNUM,
			    ElfFileSize)            SH_TABLE;
} ELF;
